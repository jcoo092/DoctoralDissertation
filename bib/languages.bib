@book{Syme2015a,
address = {Berkeley, CA},
annote = {QA75.5-76.95},
author = {Syme, Don and Granicz, Adam and Cisternino, Antonio},
% booktitle = {Expert F{\#} 4.0},
doi = {10.1007/978-1-4842-0740-6},
edition = {4 ed.},
isbn = {978-1-4842-0741-3},
publisher = {Apress},
title = {{Expert F{\#} 4.0}},
url = {http://link.springer.com/10.1007/978-1-4842-0740-6},
year = {2015}
}
@book{Butcher2014,
address = {Dallas, TX, USA},
author = {Butcher, Paul},
editor = {Tate, Bruce},
isbn = {9781937785659},
keywords = {Computer multitasking,Parallel programming (Computer science)},
pages = {289},
publisher = {The Pragmatic Programmers LLC},
series = {Pragmatic programmers},
title = {{7 Concurrency Models in 7 Weeks}},
url = {https://pragprog.com/book/pb7con/seven-concurrency-models-in-seven-weeks},
year = {2014}
}
@article{Shi2013,
abstract = {In this day and age of multicore architectures, programming language support is in urgent need for constructing programs that can take great advantage of machines with multiple cores. We present in this paper an approach to safe multicore programming in ATS, a recently developed functional programming language that supports both linear and dependent types. In particular, we formalize a type system capable of guaranteeing safe manipulation of resources on multicore machines and establish its soundness. We also provide concrete examples as well as experimental results in support of the practicality of the presented approach to multicore programming. {\textcopyright} 2012 Elsevier B.V. All rights reserved.},
annote = {ID: 271600},
author = {Shi, Rui and Xi, Hongwei},
doi = {10.1016/j.scico.2012.09.005},
file = {:D$\backslash$:/Users/jcoo092/SLR/Papers/Holding/Shi, Xi - A linear type system for multicore programming in ATS - 2013.pdf:pdf},
% isbn = {0167-6423},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {ATS,Linear types,Multicore,Type systems},
month = {8},
number = {8},
pages = {1176--1192},
title = {{A linear type system for multicore programming in ATS}},
url = {http://www.sciencedirect.com.ezproxy.auckland.ac.nz/science/article/pii/S0167642312001700 http://linkinghub.elsevier.com/retrieve/pii/S0167642312001700},
volume = {78},
year = {2013}
}
@incollection{Reppy2011,
abstract = {Concurrent ML (CML) is a higher-order concurrent language embedded in the sequential language Standard ML (SML). CML's basic programming model consists of dynamically created threads that communicate via message passing over dynamically created channels. CML also provides first-class synchronous operations, called event values, which support user-defined synchronization and communication abstractions. While the term “CML” refers to a specific language implementation, it is also used to refer to implementations of its language primitives in other systems.},
address = {Boston, MA},
author = {Reppy, John},
booktitle = {Encyclopedia of Parallel Computing},
doi = {10.1007/978-0-387-09766-4_47},
edition = {2011},
editor = {Padua, David},
isbn = {978-0-387-09766-4},
keywords = {Concurrent ML},
pages = {371--377},
publisher = {Springer US},
title = {{Concurrent ML}},
url = {https://doi.org/10.1007/978-0-387-09766-4{\_}47},
year = {2011}
}
@book{Reppy2007,
address = {New York, New York, USA},
author = {Reppy, John H.},
isbn = {978-0-521-71472-3},
keywords = {Concurrent ML,concurrent ml},
pages = {308},
publisher = {Cambridge University Press},
title = {{Concurrent Programming in ML}},
year = {2007}
}
@article{Reppy1991,
abstract = {An abstract is not available.},
author = {Reppy, John H.},
doi = {10.1145/113446.113470},
file = {:D$\backslash$:/jarak/Documents/Reppy - 1991 - CML A Higher-order Concurrent Language.pdf:pdf},
% isbn = {0-89791-428-7},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {Concurrent ML},
month = {6},
number = {6},
pages = {293--305},
title = {{CML: A Higher-order Concurrent Language}},
url = {http://portal.acm.org/citation.cfm?doid=113446.113470},
volume = {26},
year = {1991}
}
@inproceedings{Reppy2007a,
abstract = {Concurrent ML (CML) is a statically-typed higher-order concurrent language that is embedded in Standard ML. Its most notable feature is its support for first-class synchronous operations. This mechanism allows programmers to encapsulate complicated communication and synchronization protocols as first-class abstractions, which encourages a modular style of programming where the underlying channels used to communicate with a given thread are hidden behind data and type abstraction.While CML has been in active use for well over a decade, little attention has been paid to optimizing CML programs. In this paper, we present a new program analysis for statically-typed higher-order concurrent languages that enables the compile-time specialization of communication operations. This specialization is particularly important in a multiprocessor or multicore setting, where the synchronization overhead for general-purpose operations are high. Preliminary results from a prototype that we have built demonstrate that specialized channel operations are much faster than the general-purpose operations.Our analysis technique is modular (i.e., it analyzes and optimizes a single unit of abstraction at a time), which plays to the modular style of many CML programs. The analysis consists of three steps: the first is a type-sensitive control-flow analysis that uses the program's type-abstractions to compute more precise results. The second is the construction of an extended control-flow graph using the results of the CFA. The last step is an iterative analysis over the graph that approximates the usage patterns of known channels. Our analysis is designed to detect special patterns of use, such as one-shot channels, fan-in channels, and fan-out channels. We have proven the safety of our analysis and state those results. Copyright {\textcopyright} 2007 ACM.},
address = {New York, New York, USA},
author = {Reppy, John and Xiao, Yingqi},
booktitle = {Proceedings of the 34th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL '07},
doi = {10.1145/1190216.1190264},
isbn = {1595935754},
% issn = {07308566},
keywords = {Concurrent ML,Concurrent languages,ML,Message passing,Static analysis},
pages = {315},
publisher = {ACM Press},
title = {{Specialization of CML message-passing primitives}},
url = {http://portal.acm.org/citation.cfm?doid=1190216.1190264},
year = {2007}
}
@inproceedings{Atiya2005,
abstract = {The Ravenscar Profile is a restricted subset of the Ada tasking model, designed to meet the requirements of producing analysable and deterministic code. A central feature of Ravenscar is the use of protected objects to ensure mutually exclusive access to shared data. This paper uses Ravenscar protected objects to implement CSP channels in Ada - the proposed implementation is formally verified using model checking. The advantage of these Ravenscar channels is transforming the data-oriented asynchronous tasking model of Ravenscar into the cleaner message-passing synchronous model of CSP. Thus, formal proofs and techniques for model-checking CSP specifications can be applied to Ravenscar programs. In turn, this increases confidence in these programs and their reliability. Indeed, elsewhere, we use the proposed Ravenscar channels as the basis for a cost-effective technique for verifying concurrent safety-critical system. {\textcopyright} Springer-Verlag Berlin Heidelberg 2005.},
author = {Atiya, Diyaa-Addein and King, Steve},
booktitle = {Reliable Software Technology -- Ada-Europe 2005},
doi = {10.1007/11499909_7},
editor = {Vardanega, Tullio and Wellings, Andy},
file = {:H$\backslash$:/2019/Papers/To read/Atiya, King - 2005 - Extending Ravenscar with CSP Channels.pdf:pdf},
isbn = {978-3-540-31666-4},
% issn = {03029743},
pages = {79--90},
publisher = {Springer Berlin Heidelberg},
title = {{Extending Ravenscar with CSP Channels}},
url = {http://link.springer.com/10.1007/11499909{\_}7},
year = {2005}
}

@article{Reppy1988,
abstract = {Synchronous message passing via channels is an interprocess communication (IPC) mechanism found in several concurrent languages, such as CSP, occam, and Amber. Such languages provide a powerful selective I/O operation, which plays a vital role in managing communication with multiple processes. Because the channel IPC mechanism is “operation-oriented,” only procedural abstraction techniques can be used in structuring the communication/synchronization aspects of a system. This has the unfortunate effect of restricting the use of selective I/O, which in turn limits the communication structure. We propose a new, “value-oriented” approach to channel-based synchronization. We make synchronous operations first-class values, called events, in much the same way that functions are first-class values in functional programming languages. Our approach allows the use of data abstraction techniques for structuring IPC. We have incorporated events into PML, a concurrent functional programming language, and have implemented run-time support for them as part of the Pegasus system. {\textcopyright} 1988, ACM. All rights reserved.},
author = {Reppy, J. H.},
doi = {10.1145/960116.54015},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Reppy - 1988 - Synchronous Operations as First-Class Values.pdf:pdf},
issn = {15581160},
journal = {ACM SIGPLAN Notices},
keywords = {Concurrency,Concurrent ML},
month = {7},
number = {7},
pages = {250--259},
title = {{Synchronous Operations as First-Class Values}},
url = {https://dl.acm.org/doi/10.1145/960116.54015},
volume = {23},
year = {1988}
}
