@IEEEtranBSTCTL{IEEEexample:BSTcontrol,
CTLuse_url = "no",
}

@book{Braunl2001,
abstract = {This book serves as a general introduction to the area of image processing as well as to data-parallel processing. It covers a number of standard algorithms in image processing and describes their parallel implementation in a practical "hands-on" approach: Each algorithm is accompanied by numerous diagrams and program source code. Combining text, graphics, and programs is a new approach in presenting the subject matter, which will help students to better grasp the concepts - irrespective of the programming language used.The programming language chosen for all examples is a structured parallel programming language which is ideal for educational purposes. It has a number of advantages over C, and since all image processing tasks are inherently parallel, using a parallel language for presentation actually simplifies the subject matter, resulting in shorter source codes and better understanding. Sample programs and a free compiler are available on the Web.},
address = {Berlin, Heidelberg},
annote = {[electronic resource] / by Thomas Bräunl, Stefan Feyrer, Wolfgang Rapf, Michael Reinhardt.; 1 online resource; Introduction -- Point Operators -- Local Operators -- Edge Detection -- Skeletonizing -- Morphological Operators -- Segmentation -- Corner Detection -- Hough Transform -- Fourier Transform -- Texture Recognition -- Stereo Image Processing -- Analysis of Image Sequences -- Appendix: Parallaxis Parallel Programming Language; Parallaxis-III Syntax; Programming Tools; Vision Library; References -- Index.

TA1637-1638; 006.623; 006.3723},
author = {Br{\"{a}}unl, Thomas and Feyrer, Stefan and Rapf, Wolfgang and Reinhardt, Michael},
doi = {10.1007/978-3-662-04327-1},
isbn = {978-3-642-08679-3},
% mendeley-groups = {PhD/Parallel},
pages = {203},
publisher = {Springer Berlin Heidelberg},
title = {{Parallel Image Processing}},
url = {http://link.springer.com/10.1007/978-3-662-04327-1},
year = {2001}
}

@inproceedings{Chaudhuri2009,
abstract = {In Concurrent ML, synchronization abstractions can be defined and passed as values, much like functions in ML. This mechanism admits a powerful, modular style of concurrent programming, called higher-order concurrent programming. Unfortunately, it is not clear whether this style of programming is possible in languages such as Concurrent Haskell, that support only first-order message passing. Indeed, the implementation of synchronization abstractions in Concurrent ML relies on fairly low-level, languagespecific details. In this paper we show, constructively, that synchronization abstractions can be supported in a language that supports only firstorder message passing. Specifically, we implement a library that makes Concurrent ML-style programming possible in Concurrent Haskell. We begin with a core, formal implementation of synchronization abstractions in the $\pi$ -calculus. Then, we extend this implementation to encode all of Concurrent ML's concurrency primitives (and more!) in Concurrent Haskell. Our implementation is surprisingly efficient, even without possible optimizations. In several small, informal experiments, our library seems to outperform OCaml's standard library of Concurrent ML-style primitives. At the heart of our implementation is a new distributed synchronization protocol that we prove correct. Unlike several previous translations of synchronization abstractions in concurrent languages, we remain faithful to the standard semantics for Concurrent ML's concurrency primitives. For example, we retain the symmetry of choose, which can express selective communication. As a corollary, we establish that implementing selective communication on distributed machines is no harder than implementing first-order message passing on such machines. Copyright {\textcopyright} 2009 ACM.},
author = {Chaudhuri, Avik},
booktitle = {Proceedings of the 14th ACM SIGPLAN international conference on Functional programming - ICFP '09},
doi = {10.1145/1596550.1596589},
file = {:H$\backslash$:/2018/Papers/To Read/Chaudhuri - A concurrent ML library in concurrent Haskell - 2009.pdf:pdf},
isbn = {9781605583327},
% issn = {03621340},
keywords = {concurrent haskell,concurrent ml,dis-,synchronization abstractions,tributed synchronization protocol,$\pi$ -calculus},
% mendeley-groups = {PhD/FP},
month = {8},
number = {9},
pages = {269--280},
publisher = {ACM},
title = {{A concurrent ML library in concurrent Haskell}},
url = {http://portal.acm.org/citation.cfm?doid=1631687.1596589 http://dl.acm.org/citation.cfm?doid=1596550.1596589},
volume = {44},
year = {2009}
}

% @book{Hoare1985,
% address = {Englewood Cliffs, N.J.},
% author = {Hoare, Charles Antony Richard},
% isbn = {0131532898},
% keywords = {Computer programming,Parallel processing (Electronic computers)},
% % mendeley-groups = {PhD/FP/Parallel},
% publisher = {Prentice/Hall International},
% series = {Prentice-Hall international series in computer science},
% title = {{Communicating sequential processes}},
% year = {1985}
% }

@article{Agha1997,
abstract = {We present an actor language which is an extension of a simple functional language, and provide an operational semantics for this extension. Actor configurations represent open distributed systems, by which we mean that the specification of an actor system explicitly takes into account the interface with external components. We study the composability of such systems. We define and study various notions of testing equivalence on actor expressions and configurations. The model we develop provides fairness. An important result is that the three forms of equivalence, namely, convex, must, and may equivalences, collapse to two in the presence of fairness. We further develop methods for proving laws of equivalence and provide example proofs to illustrate our methodology.},
archivePrefix = {arXiv},
% arxivId = {arXiv:1011.1669v3},
author = {Agha, Gul A. and Mason, Ian A. and Smith, Scott F. and Talcott, Carolyn L.},
doi = {10.1017/S095679689700261X},
eprint = {arXiv:1011.1669v3},
file = {:H$\backslash$:/2018/Papers/To Read/foundation{\_}for{\_}actor{\_}computation.pdf:pdf},
% isbn = {9788578110796},
issn = {09567968},
journal = {Journal of Functional Programming},
% mendeley-groups = {PhD/FP/Parallel},
month = {1},
number = {1},
pages = {1--72},
% pmid = {25246403},
% publisher = {Cambridge University Press},
title = {{A foundation for actor computation}},
url = {http://www.journals.cambridge.org/abstract{\_}S095679689700261X},
volume = {7},
year = {1997}
}

% @article{Reppy1991,
% abstract = {An abstract is not available.},
% author = {Reppy, John H.},
% doi = {10.1145/113446.113470},
% file = {:H$\backslash$:/2018/Papers/To Read/Reppy - CML - 1991.pdf:pdf},
% isbn = {0-89791-428-7},
% issn = {03621340},
% journal = {ACM SIGPLAN Notices},
% % mendeley-groups = {PhD/FP},
% month = {6},
% number = {6},
% pages = {293--305},
% title = {{CML}},
% url = {http://portal.acm.org/citation.cfm?doid=113446.113470},
% volume = {26},
% year = {1991}
% }

@article{Reppy2009a,
abstract = {Concurrent ML (CML) is a high-level message-passing language that supports the construction of first-class synchronous abstractions called events. This mechanism has proven quite effective over the years and has been incorporated in a number of other languages. While CML provides a concurrent programming model, its implementation has always been limited to uniprocessors. This limitation is exploited in the implementation of the synchronization protocol that underlies the event mechanism, but with the advent of cheap parallel processing on the desktop (and laptop), it is time for Parallel CML. Parallel implementations of CML-like primitives for Java and Haskell exist, but build on high-level synchronization constructs that are unlikely to perform well. This paper presents a novel, parallel implementation of CML that exploits a purpose-built optimistic concurrency protocol designed for both correctness and performance on shared-memory multiprocessors. This work extends and completes an earlier protocol that supported just a strict subset of CML with synchronization on input, but not output events. Our main contributions are a model-checked reference implementation of the protocol and two concrete implementations. This paper focuses on Manticore's functional, continuation-based implementation but briefly discusses an independent, thread-based implementation written in C{\#} and running on Microsoft's stock, parallel run-time. Although very different in detail, both derive from the same design. Experimental evaluation of the Manticore implementation reveals good performance, dispite the extra overhead of multiprocessor synchronization.},
author = {Reppy, John and Russo, Claudio V. and Xiao, Yingqi},
doi = {10.1145/1631687.1596588},
file = {:H$\backslash$:/2018/Papers/To Read/Reppy - Parallel-Concurrent-ML - 2009.pdf:pdf},
% isbn = {978-1-60558-332-7},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {and a powerful abstraction,called first-class synchronous operations,cml extends sml with,concurrency,for building syn-,mecha-,message passing,ml,mthm97,nism,parallelism,passing over typed channels,synchronous message},
% mendeley-groups = {PhD/FP/Parallel},
number = {9},
pages = {257},
title = {{Parallel concurrent ML}},
url = {http://portal.acm.org/citation.cfm?doid=1631687.1596588},
volume = {44},
year = {2009}
}

@incollection{Drory2014,
abstract = {Semi-global matching, originally introduced in the context of dense stereo, is a very successful heuristic to minimize the energy of a pairwise multi-label Markov Random Field defined on a grid. We offer the first principled expla-nation of this empirically successful algorithm, and clarify its exact relation to belief propagation and tree-reweighted message passing. One outcome of this new connection is an uncertainty measure for the MAP label of a variable in a Markov Random Field.},
author = {Drory, Amnon and Haubold, Carsten and Avidan, Shai and Hamprecht, Fred A.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-11752-2_4},
editor = {Jiang, Xiaoyi and Hornegger, Joachim and Koch, Reinhard},
file = {:H$\backslash$:/2018/Papers/To Read/Stereo matching/SGM/Drory et al. - Semi-Global Matching A Principled Derivation in Terms of Message Passing - 2014.pdf:pdf},
isbn = {9783319117515},
% issn = {16113349},
% mendeley-groups = {PhD/Computer Vision},
pages = {43--53},
title = {{Semi-Global Matching: A Principled Derivation in Terms of Message Passing}},
url = {http://link.springer.com/10.1007/978-3-319-11752-2{\_}4},
volume = {8753},
year = {2014}
}

@book{Shun2017,
abstract = {Parallelism is the key to achieving high performance in computing. However, writing efficient and scalable parallel programs is notoriously difficult, and often requires significant expertise. To address this challenge, it is crucial to provide programmers with high-level tools to enable them to develop solutions efficiently, and at the same time emphasize the theoretical and practical aspects of algorithm design to allow the solutions developed to run efficiently under all possible settings. This thesis addresses this challenge using a three-pronged approach consisting of the design of shared-memory programming techniques, frameworks, and algorithms for important problems in computing. The thesis provides evidence that with appropriate programming techniques, frameworks, and algorithms, shared-memory programs can be simple, fast, and scalable, both in theory and in practice. The results developed in this thesis serve to ease the transition into the multicore era. The first part of this thesis introduces tools and techniques for deterministic parallel programming, including means for encapsulating nondeterminism via powerful commutative building blocks, as well as a novel framework for executing sequential iterative loops in parallel, which lead to deterministic parallel algorithms that are efficient both in theory and in practice. The second part of this thesis introduces Ligra, the first high-level shared memory framework for parallel graph traversal algorithms. The framework allows programmers to express graph traversal algorithms using very short and concise code, delivers performance competitive with that of highly-optimized code, and is up to orders of magnitude faster than existing systems designed for distributed memory. This part of the thesis also introduces Ligra+, which extends Ligra with graph compression techniques to reduce space usage and improve parallel performance at the same time, and is also the first graph processing system to support in-memory graph compression. The third and fourth parts of this thesis bridge the gap between theory and practice in parallel algorithm design by introducing the first algorithms for a variety of important problems on graphs and strings that are efficient both in theory and in practice. For example, the thesis develops the first linear-work and polylogarithmic-depth algorithms for suffix tree construction and graph connectivity that are also practical, as well as a work-efficient, polylogarithmicdepth, and cache-efficient shared-memory algorithm for triangle computations that achieves a 2–5x speedup over the best existing algorithms on 40 cores.},
author = {Shun, Julian},
doi = {10.1145/3018787},
isbn = {9781970001914},
% mendeley-groups = {PhD},
month = {6},
number = {May},
publisher = {ACM},
title = {{Shared-Memory Parallelism Can Be Simple, Fast, and Scalable}},
url = {http://reports-archive.adm.cs.cmu.edu/anon/2015/CMU-CS-15-108.pdf https://dl.acm.org/citation.cfm?id=3018787},
year = {2017}
}

% @article{Liang2011,
% abstract = {Belief propagation (BP) is an effective algorithm for solving energy minimization problems in computer vision. However, it requires enormous memory, bandwidth, and computation because messages are iteratively passed between nodes in the Markov random field (MRF). In this paper, we propose two methods to address this problem. The first method is a message passing scheme called tile-based belief propagation. The key idea of this method is that a message can be well approximated from other faraway ones. We split the MRF into many tiles and perform BP within each one. To preserve the global optimality, we store the outgoing boundary messages of a tile and use them when performing BP in the neighboring tiles. The tile-based BP only requires 1-5{\%} memory and 0.2-1{\%} bandwidth of the ordinary BP. The second method is an O(L) message construction algorithm for the robust functions commonly used for describing the smoothness terms in the energy function. We find that many variables in constructing a message are repetitive; thus these variables can be calculated once and reused many times. The proposed algorithms are suitable for parallel implementations. We design a low-power VLSI circuit for disparity estimation that can construct 440 M messages per second and generate high quality disparity maps in near real-time. We also implement the proposed algorithms on a GPU, which can calculate messages 4 times faster than the sequential O(L) method.},
% author = {Liang, Chia Kai and Cheng, Chao Chung and Lai, Yen Chieh and Chen, Liang Gee and Chen, Homer H},
% doi = {10.1109/TCSVT.2011.2125570},
% file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Liang et al. - 2011 - Hardware-Efficient Belief Propagation.pdf:pdf},
% isbn = {9781424439935},
% issn = {10518215},
% journal = {IEEE Transactions on Circuits and Systems for Video Technology},
% keywords = {Belief propagation,Markov random field,VLSI circuit design,embedded systems,energy minimization,general-purpose computation on GPU},
% % mendeley-groups = {PhD/Computer Vision},
% month = {5},
% number = {5},
% pages = {525--537},
% title = {{Hardware-efficient belief propagation}},
% url = {http://ieeexplore.ieee.org/document/5733391/},
% volume = {21},
% year = {2011}
% }

@article{Boyapati2002,
abstract = {This paper presents a new static type system for multithreaded programs; well-typed programs in our system are guaranteed to be free of data races and deadlocks. Our type system allows programmers to partition the locks into a fixed number of equivalence classes and specify a partial order among the equivalence classes. The type checker then statically verifies that whenever a thread holds more than one lock, the thread acquires the locks in the descending order.Our system also allows programmers to use recursive tree-based data structures to describe the partial order. For example, programmers can specify that nodes in a tree must be locked in the tree order. Our system allows mutations to the data structure that change the partial order at runtime. The type checker statically verifies that the mutations do not introduce cycles in the partial order, and that the changing of the partial order does not lead to deadlocks. We do not know of any other sound static system for preventing deadlocks that allows changes to the partial order at runtime.Our system uses a variant of ownership types to prevent data races and deadlocks. Ownership types provide a statically enforceable way of specifying object encapsulation. Ownership types are useful for preventing data races and deadlocks because the lock that protects an object can also protect its encapsulated objects. This paper describes how to use our type system to statically enforce object encapsulation as well as prevent data races and deadlocks. The paper also contains a detailed discussion of different ownership type systems and the encapsulation guarantees they provide.},
author = {Boyapati, Chandrasekhar and Lee, Robert and Rinard, Martin},
doi = {10.1145/583854.582440},
file = {:C$\backslash$:/Misc/James/Computer Science/Papers/p211-boyapati.pdf:pdf},
% isbn = {1581134711},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {all or part of,data races,deadlocks,encapsulation,is granted without fee,or hard copies of,ownership types,permission to make digital,personal or classroom use,provided that copies are,this work for},
month = {11},
number = {11},
pages = {211},
title = {{Ownership types for safe programming}},
url = {http://portal.acm.org/citation.cfm?doid=583854.582440},
volume = {37},
year = {2002}
}

@article{Bocq2012,
abstract = {Molecule is a domain specific language library embedded in Scala for easing the creation of scalable and modular concurrent applications on the JVM. Concurrent applications are modeled as parallel process networks that exchange information over mobile and type-safe messaging interfaces. In this paper, we present a concurrent programming environment that combines functional and imperative programming. Using a monad, we structure the sequential or parallel coordination of user-level threads, without JVM modifications or compiler support. Our mobile channel interfaces expose reusable and parallelizable higher-order functions, as if they were streams in a lazily evaluated functional programming language. The support for graceful termination of entire process networks is simplified by integrating channel poisoning with monadic exceptions and resource control. Our runtime and system-level interfaces leverage message batching and a novel flow parallel scheduler to limit expensive context switches in multicore environments. We illustrate the expressiveness and performance benefits on a 24-core AMD Opteron machine with three classical examples: a thread ring, a genuine prime sieve and a chameneos-redux.},
author = {Bocq, S{\'{e}}bastien and Daenen, Koen},
doi = {10.1145/2398857.2384640},
file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bocq, Daenen - 2012 - Molecule.pdf:pdf},
% isbn = {978-1-4503-1561-6},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {DSEl,DSl,concurrent,functional programming,multicore,parallel,process networks,scala,stream},
month = {11},
number = {10},
pages = {315},
title = {{Molecule}},
url = {http://dl.acm.org/citation.cfm?doid=2398857.2384640},
volume = {47},
year = {2012}
}

@article{Seinstra2004,
abstract = {Although many image processing applications are ideally suited for parallel implementation, most researchers in imaging do not benefit from high-performance computing on a daily basis. Essentially, this is due to the fact that no parallelization tools exist that truly match the image processing researcher's frame of reference. As it is unrealistic to expect imaging researchers to become experts in parallel computing, tools must be provided to allow them to develop high-performance applications in a highly familiar manner. In an attempt to provide such a tool, we have designed a software architecture that allows transparent (i.e. sequential) implementation of data parallel imaging applications for execution on homogeneous distributed memory MIMD-style multicomputers. This paper presents an extensive overview of the design rationale behind the software architecture, and gives an assessment of the architecture's effectiveness in providing significant performance gains. In particular, we describe the implementation and automatic parallelization of three well-known example applications that contain many fundamental imaging operations: (1) template matching; (2) multi-baseline stereo vision; and (3) line detection. Based on experimental results we conclude that our software architecture constitutes a powerful and user-friendly tool for obtaining high performance in many important image processing research areas. Copyright {\&}copy; 2004 John Wiley {\&} Sons, Ltd.},
author = {Seinstra, F. J. and Koelma, D.},
doi = {10.1002/cpe.765},
file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Seinstra, Koelma - 2004 - User transparency A fully sequential programming model for efficient data parallel image processing.pdf:pdf},
issn = {1532-0626},
journal = {Concurrency and Computation: Practice and Experience},
keywords = {Data parallel image processing,Performance evaluation,Software architecture design},
% mendeley-groups = {PhD/Parallel},
month = {5},
number = {6},
pages = {611--644},
% publisher = {John Wiley {\&} Sons, Ltd.},
title = {{User transparency: a fully sequential programming model for efficient data parallel image processing}},
url = {http://dx.doi.org/10.1002/cpe.765 http://doi.wiley.com/10.1002/cpe.765},
volume = {16},
year = {2004}
}

@article{Ragan-Kelley2017,
author = {Ragan-Kelley, Jonathan and Adams, Andrew and Sharlet, Dillon and Barnes, Connelly and Paris, Sylvain and Levoy, Marc and Amarasinghe, Saman and Durand, Fr{\'{e}}do},
doi = {10.1145/3150211},
file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ragan-Kelley et al. - 2017 - Halide.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
% mendeley-groups = {PhD/FP/SLR/CV},
month = {12},
number = {1},
pages = {106--115},
title = {{Halide}},
url = {http://dl.acm.org/citation.cfm?doid=3176926.3150211},
volume = {61},
year = {2017}
}

@inproceedings{Sanchez2012,
abstract = {Climacteric increases the risk of thrombotic events by alteration of plasmatic coagulation. Up to now, less is known about changes in platelet- (PMP) and endothelial cell-derived microparticles (EMP).},
author = {Sanchez, Ricardo M. and Rodriguez, Paul A.},
booktitle = {2012 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)},
doi = {10.1109/ICASSP.2012.6288187},
isbn = {978-1-4673-0046-9},
% issn = {15206149},
keywords = {Nonlinear filters,Parallel Algorithms},
% mendeley-groups = {PhD/Computer Vision},
month = {3},
pages = {1549--1552},
% pmid = {22627113},
publisher = {IEEE},
title = {{Bidimensional median filter for parallel computing architectures}},
url = {http://ieeexplore.ieee.org/document/6288187/},
year = {2012}
}

@article{Wu2011,
abstract = {In this paper, we propose an improved two-stage scheme for the removal of salt-and-pepper noise based on an efficient impulse detector and the edge-preserving total variation inpainting model. We test the proposed algorithm on the four images corrupted by salt-and-pepper noise with a wide range of noise levels varied from 10{\%} to 95{\%}, and compare it with the six other well known filters. Further, we evaluate quantitatively the performance of these filters with the peak signal-to-noise ratio (PSNR), the measure of structural similarity (SSIM) and the image enhancement factor (IEF). The experimental results have demonstrated that the proposed filter performs impressively in noise suppression and edge preservation. {\textcopyright} 2011 Elsevier B.V. All rights reserved.},
author = {Wu, Jian and Tang, Chen},
doi = {10.1016/j.patrec.2011.09.025},
% isbn = {0167-8655},
issn = {01678655},
journal = {Pattern Recognition Letters},
keywords = {Edge-preservation,Image denoising,Impulse noise,The two-stage scheme,Total variation inpainting},
% mendeley-groups = {PhD/Computer Vision},
month = {11},
number = {15},
pages = {1974--1981},
title = {{An efficient decision-based and edge-preserving method for salt-and-pepper noise removal}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0167865511002984},
volume = {32},
year = {2011}
}

@article{Gao2015,
abstract = {In this paper, an efficient three-stage scheme for the removal of salt {\&} pepper noise based on an efficient impulse detector, an adaptive mean-median filter and the total variation inpainting method was proposed. This approach removes salt {\&} pepper noise by detecting, estimating and modifying noisy pixels in an image. If a pixel is classified as noise, its intensity is first estimated by a mean-median filter; and then an accurate estimation is obtained through the use of the total variation inpainting method. Conversely, the pixel value is kept unchanged when it is classified as noise-free, yielding the quality of the restored image being well maintained. Experimental results demonstrate that the proposed three-stage approach can not only remove salt {\&} pepper impulse noise efficiently, but also preserve the detailed information of an image well.},
author = {Gao, Guorong and Liu, Yanping},
doi = {10.1016/j.ijleo.2014.11.004},
issn = {00304026},
journal = {Optik},
keywords = {Image denoising,Mean-median filter,Salt {\&} pepper noise,Total variation inpainting},
% mendeley-groups = {PhD/Computer Vision},
month = {2},
number = {4},
pages = {467--471},
title = {{An efficient three-stage approach for removing salt {\&} pepper noise from digital images}},
url = {https://linkinghub.elsevier.com/retrieve/pii/S0030402614013254},
volume = {126},
year = {2015}
}

@incollection{Boncelet2005,
abstract = {Noise is generally the unwanted component in an image. This chapter reviews commonly used image noise models. Some of these are naturally occurring (for example, the Gaussian noise), and some result from various processes (for example, quantization and transmission). The most common performance criterion is the mean squared error (MSE). The estimator that minimizes the MSE is called the minimum mean squared error estimator (MMSE). The chapter explains that noise occurs in images for many reasons. The Gaussian noise is a part of almost any signal. For example, the familiar white noise on a weak television station is well modeled as Gaussian. Because image sensors must count photons, especially in low light situations, and the number of photons counted is a random quantity, images often have photon counting noise. The grain noise in photographic films is sometimes modeled as Gaussian and sometimes as Poisson. Many images are corrupted by salt and pepper noise, as if someone had sprinkled black and white dots on the image. Other noises include quantization noise and speckle in coherent light situations. {\textcopyright} 2005 Elsevier Inc. All rights reserved.},
address = {Burlington},
author = {Boncelet, Charles},
booktitle = {Handbook of Image and Video Processing},
doi = {10.1016/B978-012119792-6/50087-5},
edition = {Second},
editor = {Bovik, A L},
isbn = {9780121197926},
% mendeley-groups = {PhD/Computer Vision},
pages = {397--409},
publisher = {Elsevier},
series = {Communications, Networking and Multimedia},
title = {{Image Noise Models}},
url = {http://www.sciencedirect.com/science/article/pii/B9780121197926500875 http://linkinghub.elsevier.com/retrieve/pii/B9780121197926500875},
year = {2005}
}

@article{Perrot2014,
abstract = {Median filtering is a well-known method used in a wide range of application frameworks as well as a standalone filter, especially for salt-and-pepper denoising. It is able to highly reduce the power of noise while minimizing edge blurring. Currently, existing algorithms and implementations are quite efficient but may be improved as far as processing speed is concerned, which has led us to further investigate the specificities of modern GPUs. In this paper, we propose the GPU implementation of fixed-size kernel median filters, able to output up to 1.85 billion pixels per second on C2070 Tesla cards. Based on a Branchless Vectorized Median class algorithm and implemented through memory fine tuning and the use of GPU registers, our median drastically outperforms existing implementations, resulting, as far as we know, in the fastest median filter to date.},
author = {Perrot, Gilles and Domas, St{\'{e}}phane and Couturier, Rapha{\"{e}}l},
doi = {10.1007/s11265-013-0799-2},
% isbn = {1433-7851},
issn = {1939-8018},
journal = {Journal of Signal Processing Systems},
keywords = {Filter,GPU,Median},
% mendeley-groups = {PhD},
month = {6},
number = {3},
pages = {185--190},
% pmid = {15340959},
title = {{Fine-tuned High-speed Implementation of a GPU-based Median Filter}},
url = {http://link.springer.com/10.1007/s11265-013-0799-2},
volume = {75},
year = {2014}
}

@article{Perreault2007,
abstract = {The median filter is one of the basic building blocks in many image processing situations. However, its use has long been hampered by its algorithmic complexity O(tau) of in the kernel radius. With the trend toward larger images and proportionally larger filter kernels, the need for a more efficient median filtering algorithm becomes pressing. In this correspondence, a new, simple, yet much faster, algorithm exhibiting O(1) runtime complexity is described and analyzed. It is compared and benchmarked against previous algorithms. Extensions to higher dimensional or higher precision data and an approximation to a circular kernel are presented, as well.},
author = {Perreault, Simon and Hebert, Patrick},
doi = {10.1109/TIP.2007.902329},
file = {:D$\backslash$:/Users/jcoo092/Writing/2018/IVCNZ18/References/Perreault, Hebert - Median Filtering in Constant Time - 2007.pdf:pdf},
% isbn = {1057-7149 (Print)},
issn = {1057-7149},
journal = {IEEE Transactions on Image Processing},
keywords = {Algorithms,Complexity theory,Image processing,Median filters},
% mendeley-groups = {PhD/Computer Vision},
month = {9},
number = {9},
pages = {2389--2394},
% pmid = {17784612},
title = {{Median Filtering in Constant Time}},
url = {http://nomis80.org/ctmf.html http://ieeexplore.ieee.org/document/4287006/},
volume = {16},
year = {2007}
}
