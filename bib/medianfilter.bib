@book{Braunl2001,
abstract = {This book serves as a general introduction to the area of image processing as well as to data-parallel processing. It covers a number of standard algorithms in image processing and describes their parallel implementation in a practical "hands-on" approach: Each algorithm is accompanied by numerous diagrams and program source code. Combining text, graphics, and programs is a new approach in presenting the subject matter, which will help students to better grasp the concepts - irrespective of the programming language used.The programming language chosen for all examples is a structured parallel programming language which is ideal for educational purposes. It has a number of advantages over C, and since all image processing tasks are inherently parallel, using a parallel language for presentation actually simplifies the subject matter, resulting in shorter source codes and better understanding. Sample programs and a free compiler are available on the Web.},
address = {Berlin, Heidelberg},
annote = {[electronic resource] / by Thomas Bräunl, Stefan Feyrer, Wolfgang Rapf, Michael Reinhardt.; 1 online resource; Introduction -- Point Operators -- Local Operators -- Edge Detection -- Skeletonizing -- Morphological Operators -- Segmentation -- Corner Detection -- Hough Transform -- Fourier Transform -- Texture Recognition -- Stereo Image Processing -- Analysis of Image Sequences -- Appendix: Parallaxis Parallel Programming Language; Parallaxis-III Syntax; Programming Tools; Vision Library; References -- Index.

TA1637-1638; 006.623; 006.3723},
author = {Br{\"{a}}unl, Thomas and Feyrer, Stefan and Rapf, Wolfgang and Reinhardt, Michael},
doi = {10.1007/978-3-662-04327-1},
isbn = {978-3-642-08679-3},
% mendeley-groups = {PhD/Parallel},
pages = {203},
publisher = {Springer Berlin Heidelberg},
title = {{Parallel Image Processing}},
url = {http://link.springer.com/10.1007/978-3-662-04327-1},
year = {2001}
}

@inproceedings{Chaudhuri2009,
abstract = {In Concurrent ML, synchronization abstractions can be defined and passed as values, much like functions in ML. This mechanism admits a powerful, modular style of concurrent programming, called higher-order concurrent programming. Unfortunately, it is not clear whether this style of programming is possible in languages such as Concurrent Haskell, that support only first-order message passing. Indeed, the implementation of synchronization abstractions in Concurrent ML relies on fairly low-level, languagespecific details. In this paper we show, constructively, that synchronization abstractions can be supported in a language that supports only firstorder message passing. Specifically, we implement a library that makes Concurrent ML-style programming possible in Concurrent Haskell. We begin with a core, formal implementation of synchronization abstractions in the $\pi$ -calculus. Then, we extend this implementation to encode all of Concurrent ML's concurrency primitives (and more!) in Concurrent Haskell. Our implementation is surprisingly efficient, even without possible optimizations. In several small, informal experiments, our library seems to outperform OCaml's standard library of Concurrent ML-style primitives. At the heart of our implementation is a new distributed synchronization protocol that we prove correct. Unlike several previous translations of synchronization abstractions in concurrent languages, we remain faithful to the standard semantics for Concurrent ML's concurrency primitives. For example, we retain the symmetry of choose, which can express selective communication. As a corollary, we establish that implementing selective communication on distributed machines is no harder than implementing first-order message passing on such machines. Copyright {\textcopyright} 2009 ACM.},
author = {Chaudhuri, Avik},
booktitle = {Proceedings of the 14th ACM SIGPLAN international conference on Functional programming - ICFP '09},
doi = {10.1145/1596550.1596589},
file = {:H$\backslash$:/2018/Papers/To Read/Chaudhuri - A concurrent ML library in concurrent Haskell - 2009.pdf:pdf},
isbn = {9781605583327},
% issn = {03621340},
keywords = {concurrent haskell,concurrent ml,dis-,synchronization abstractions,tributed synchronization protocol,$\pi$ -calculus},
% mendeley-groups = {PhD/FP},
month = {8},
number = {9},
pages = {269--280},
publisher = {ACM},
title = {{A concurrent ML library in concurrent Haskell}},
url = {http://portal.acm.org/citation.cfm?doid=1631687.1596589 http://dl.acm.org/citation.cfm?doid=1596550.1596589},
volume = {44},
year = {2009}
}

% @book{Hoare1985,
% address = {Englewood Cliffs, N.J.},
% author = {Hoare, Charles Antony Richard},
% isbn = {0131532898},
% keywords = {Computer programming,Parallel processing (Electronic computers)},
% % mendeley-groups = {PhD/FP/Parallel},
% publisher = {Prentice/Hall International},
% series = {Prentice-Hall international series in computer science},
% title = {{Communicating sequential processes}},
% year = {1985}
% }

@article{Agha1997,
abstract = {We present an actor language which is an extension of a simple functional language, and provide an operational semantics for this extension. Actor configurations represent open distributed systems, by which we mean that the specification of an actor system explicitly takes into account the interface with external components. We study the composability of such systems. We define and study various notions of testing equivalence on actor expressions and configurations. The model we develop provides fairness. An important result is that the three forms of equivalence, namely, convex, must, and may equivalences, collapse to two in the presence of fairness. We further develop methods for proving laws of equivalence and provide example proofs to illustrate our methodology.},
archivePrefix = {arXiv},
% arxivId = {arXiv:1011.1669v3},
author = {Agha, Gul A. and Mason, Ian A. and Smith, Scott F. and Talcott, Carolyn L.},
doi = {10.1017/S095679689700261X},
eprint = {arXiv:1011.1669v3},
file = {:H$\backslash$:/2018/Papers/To Read/foundation{\_}for{\_}actor{\_}computation.pdf:pdf},
% isbn = {9788578110796},
issn = {09567968},
journal = {Journal of Functional Programming},
% mendeley-groups = {PhD/FP/Parallel},
month = {1},
number = {1},
pages = {1--72},
% pmid = {25246403},
% publisher = {Cambridge University Press},
title = {{A foundation for actor computation}},
url = {http://www.journals.cambridge.org/abstract{\_}S095679689700261X},
volume = {7},
year = {1997}
}

% @article{Reppy1991,
% abstract = {An abstract is not available.},
% author = {Reppy, John H.},
% doi = {10.1145/113446.113470},
% file = {:H$\backslash$:/2018/Papers/To Read/Reppy - CML - 1991.pdf:pdf},
% isbn = {0-89791-428-7},
% issn = {03621340},
% journal = {ACM SIGPLAN Notices},
% % mendeley-groups = {PhD/FP},
% month = {6},
% number = {6},
% pages = {293--305},
% title = {{CML}},
% url = {http://portal.acm.org/citation.cfm?doid=113446.113470},
% volume = {26},
% year = {1991}
% }

@article{Reppy2009a,
abstract = {Concurrent ML (CML) is a high-level message-passing language that supports the construction of first-class synchronous abstractions called events. This mechanism has proven quite effective over the years and has been incorporated in a number of other languages. While CML provides a concurrent programming model, its implementation has always been limited to uniprocessors. This limitation is exploited in the implementation of the synchronization protocol that underlies the event mechanism, but with the advent of cheap parallel processing on the desktop (and laptop), it is time for Parallel CML. Parallel implementations of CML-like primitives for Java and Haskell exist, but build on high-level synchronization constructs that are unlikely to perform well. This paper presents a novel, parallel implementation of CML that exploits a purpose-built optimistic concurrency protocol designed for both correctness and performance on shared-memory multiprocessors. This work extends and completes an earlier protocol that supported just a strict subset of CML with synchronization on input, but not output events. Our main contributions are a model-checked reference implementation of the protocol and two concrete implementations. This paper focuses on Manticore's functional, continuation-based implementation but briefly discusses an independent, thread-based implementation written in C{\#} and running on Microsoft's stock, parallel run-time. Although very different in detail, both derive from the same design. Experimental evaluation of the Manticore implementation reveals good performance, despite the extra overhead of multiprocessor synchronization.},
author = {Reppy, John and Russo, Claudio V. and Xiao, Yingqi},
doi = {10.1145/1631687.1596588},
file = {:H$\backslash$:/2018/Papers/To Read/Reppy - Parallel-Concurrent-ML - 2009.pdf:pdf},
% isbn = {978-1-60558-332-7},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {and a powerful abstraction,called first-class synchronous operations,cml extends sml with,concurrency,for building syn-,mecha-,message passing,ml,mthm97,nism,parallelism,passing over typed channels,synchronous message},
% mendeley-groups = {PhD/FP/Parallel},
month = {8},
number = {9},
pages = {257},
title = {{Parallel concurrent ML}},
url = {http://portal.acm.org/citation.cfm?doid=1631687.1596588},
volume = {44},
year = {2009}
}

@incollection{Drory2014,
abstract = {Semi-global matching, originally introduced in the context of dense stereo, is a very successful heuristic to minimize the energy of a pairwise multi-label Markov Random Field defined on a grid. We offer the first principled expla-nation of this empirically successful algorithm, and clarify its exact relation to belief propagation and tree-reweighted message passing. One outcome of this new connection is an uncertainty measure for the MAP label of a variable in a Markov Random Field.},
author = {Drory, Amnon and Haubold, Carsten and Avidan, Shai and Hamprecht, Fred A.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-11752-2_4},
editor = {Jiang, Xiaoyi and Hornegger, Joachim and Koch, Reinhard},
file = {:H$\backslash$:/2018/Papers/To Read/Stereo matching/SGM/Drory et al. - Semi-Global Matching A Principled Derivation in Terms of Message Passing - 2014.pdf:pdf},
isbn = {9783319117515},
% issn = {16113349},
% mendeley-groups = {PhD/Computer Vision},
pages = {43--53},
title = {{Semi-Global Matching: A Principled Derivation in Terms of Message Passing}},
url = {http://link.springer.com/10.1007/978-3-319-11752-2{\_}4},
volume = {8753},
year = {2014}
}

@book{Shun2017,
abstract = {Parallelism is the key to achieving high performance in computing. However, writing efficient and scalable parallel programs is notoriously difficult, and often requires significant expertise. To address this challenge, it is crucial to provide programmers with high-level tools to enable them to develop solutions efficiently, and at the same time emphasize the theoretical and practical aspects of algorithm design to allow the solutions developed to run efficiently under all possible settings. This thesis addresses this challenge using a three-pronged approach consisting of the design of shared-memory programming techniques, frameworks, and algorithms for important problems in computing. The thesis provides evidence that with appropriate programming techniques, frameworks, and algorithms, shared-memory programs can be simple, fast, and scalable, both in theory and in practice. The results developed in this thesis serve to ease the transition into the multicore era. The first part of this thesis introduces tools and techniques for deterministic parallel programming, including means for encapsulating nondeterminism via powerful commutative building blocks, as well as a novel framework for executing sequential iterative loops in parallel, which lead to deterministic parallel algorithms that are efficient both in theory and in practice. The second part of this thesis introduces Ligra, the first high-level shared memory framework for parallel graph traversal algorithms. The framework allows programmers to express graph traversal algorithms using very short and concise code, delivers performance competitive with that of highly-optimized code, and is up to orders of magnitude faster than existing systems designed for distributed memory. This part of the thesis also introduces Ligra+, which extends Ligra with graph compression techniques to reduce space usage and improve parallel performance at the same time, and is also the first graph processing system to support in-memory graph compression. The third and fourth parts of this thesis bridge the gap between theory and practice in parallel algorithm design by introducing the first algorithms for a variety of important problems on graphs and strings that are efficient both in theory and in practice. For example, the thesis develops the first linear-work and polylogarithmic-depth algorithms for suffix tree construction and graph connectivity that are also practical, as well as a work-efficient, polylogarithmicdepth, and cache-efficient shared-memory algorithm for triangle computations that achieves a 2–5x speedup over the best existing algorithms on 40 cores.},
author = {Shun, Julian},
doi = {10.1145/3018787},
isbn = {9781970001914},
% mendeley-groups = {PhD},
month = {6},
number = {May},
publisher = {ACM},
title = {{Shared-Memory Parallelism Can Be Simple, Fast, and Scalable}},
url = {http://reports-archive.adm.cs.cmu.edu/anon/2015/CMU-CS-15-108.pdf https://dl.acm.org/citation.cfm?id=3018787},
year = {2017}
}

% @article{Liang2011,
% abstract = {Belief propagation (BP) is an effective algorithm for solving energy minimization problems in computer vision. However, it requires enormous memory, bandwidth, and computation because messages are iteratively passed between nodes in the Markov random field (MRF). In this paper, we propose two methods to address this problem. The first method is a message passing scheme called tile-based belief propagation. The key idea of this method is that a message can be well approximated from other faraway ones. We split the MRF into many tiles and perform BP within each one. To preserve the global optimality, we store the outgoing boundary messages of a tile and use them when performing BP in the neighboring tiles. The tile-based BP only requires 1-5{\%} memory and 0.2-1{\%} bandwidth of the ordinary BP. The second method is an O(L) message construction algorithm for the robust functions commonly used for describing the smoothness terms in the energy function. We find that many variables in constructing a message are repetitive; thus these variables can be calculated once and reused many times. The proposed algorithms are suitable for parallel implementations. We design a low-power VLSI circuit for disparity estimation that can construct 440 M messages per second and generate high quality disparity maps in near real-time. We also implement the proposed algorithms on a GPU, which can calculate messages 4 times faster than the sequential O(L) method.},
% author = {Liang, Chia Kai and Cheng, Chao Chung and Lai, Yen Chieh and Chen, Liang Gee and Chen, Homer H},
% doi = {10.1109/TCSVT.2011.2125570},
% file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Liang et al. - 2011 - Hardware-Efficient Belief Propagation.pdf:pdf},
% isbn = {9781424439935},
% issn = {10518215},
% journal = {IEEE Transactions on Circuits and Systems for Video Technology},
% keywords = {Belief propagation,Markov random field,VLSI circuit design,embedded systems,energy minimization,general-purpose computation on GPU},
% % mendeley-groups = {PhD/Computer Vision},
% month = {5},
% number = {5},
% pages = {525--537},
% title = {{Hardware-efficient belief propagation}},
% url = {http://ieeexplore.ieee.org/document/5733391/},
% volume = {21},
% year = {2011}
% }

@article{Boyapati2002,
abstract = {This paper presents a new static type system for multithreaded programs; well-typed programs in our system are guaranteed to be free of data races and deadlocks. Our type system allows programmers to partition the locks into a fixed number of equivalence classes and specify a partial order among the equivalence classes. The type checker then statically verifies that whenever a thread holds more than one lock, the thread acquires the locks in the descending order.Our system also allows programmers to use recursive tree-based data structures to describe the partial order. For example, programmers can specify that nodes in a tree must be locked in the tree order. Our system allows mutations to the data structure that change the partial order at runtime. The type checker statically verifies that the mutations do not introduce cycles in the partial order, and that the changing of the partial order does not lead to deadlocks. We do not know of any other sound static system for preventing deadlocks that allows changes to the partial order at runtime.Our system uses a variant of ownership types to prevent data races and deadlocks. Ownership types provide a statically enforceable way of specifying object encapsulation. Ownership types are useful for preventing data races and deadlocks because the lock that protects an object can also protect its encapsulated objects. This paper describes how to use our type system to statically enforce object encapsulation as well as prevent data races and deadlocks. The paper also contains a detailed discussion of different ownership type systems and the encapsulation guarantees they provide.},
author = {Boyapati, Chandrasekhar and Lee, Robert and Rinard, Martin},
doi = {10.1145/583854.582440},
file = {:C$\backslash$:/Misc/James/Computer Science/Papers/p211-boyapati.pdf:pdf},
% isbn = {1581134711},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {all or part of,data races,deadlocks,encapsulation,is granted without fee,or hard copies of,ownership types,permission to make digital,personal or classroom use,provided that copies are,this work for},
month = {11},
number = {11},
pages = {211},
title = {{Ownership types for safe programming}},
url = {http://portal.acm.org/citation.cfm?doid=583854.582440},
volume = {37},
year = {2002}
}

@article{Bocq2012,
abstract = {Molecule is a domain specific language library embedded in Scala for easing the creation of scalable and modular concurrent applications on the JVM. Concurrent applications are modeled as parallel process networks that exchange information over mobile and type-safe messaging interfaces. In this paper, we present a concurrent programming environment that combines functional and imperative programming. Using a monad, we structure the sequential or parallel coordination of user-level threads, without JVM modifications or compiler support. Our mobile channel interfaces expose reusable and parallelizable higher-order functions, as if they were streams in a lazily evaluated functional programming language. The support for graceful termination of entire process networks is simplified by integrating channel poisoning with monadic exceptions and resource control. Our runtime and system-level interfaces leverage message batching and a novel flow parallel scheduler to limit expensive context switches in multicore environments. We illustrate the expressiveness and performance benefits on a 24-core AMD Opteron machine with three classical examples: a thread ring, a genuine prime sieve and a chameneos-redux.},
author = {Bocq, S{\'{e}}bastien and Daenen, Koen},
doi = {10.1145/2398857.2384640},
file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Bocq, Daenen - 2012 - Molecule.pdf:pdf},
% isbn = {978-1-4503-1561-6},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {DSEl,DSl,concurrent,functional programming,multicore,parallel,process networks,scala,stream},
month = {11},
number = {10},
pages = {315},
title = {{Molecule}},
url = {http://dl.acm.org/citation.cfm?doid=2398857.2384640},
volume = {47},
year = {2012}
}

@article{Seinstra2004,
abstract = {Although many image processing applications are ideally suited for parallel implementation, most researchers in imaging do not benefit from high-performance computing on a daily basis. Essentially, this is due to the fact that no parallelization tools exist that truly match the image processing researcher's frame of reference. As it is unrealistic to expect imaging researchers to become experts in parallel computing, tools must be provided to allow them to develop high-performance applications in a highly familiar manner. In an attempt to provide such a tool, we have designed a software architecture that allows transparent (i.e. sequential) implementation of data parallel imaging applications for execution on homogeneous distributed memory MIMD-style multicomputers. This paper presents an extensive overview of the design rationale behind the software architecture, and gives an assessment of the architecture's effectiveness in providing significant performance gains. In particular, we describe the implementation and automatic parallelization of three well-known example applications that contain many fundamental imaging operations: (1) template matching; (2) multi-baseline stereo vision; and (3) line detection. Based on experimental results we conclude that our software architecture constitutes a powerful and user-friendly tool for obtaining high performance in many important image processing research areas. Copyright {\&}copy; 2004 John Wiley {\&} Sons, Ltd.},
author = {Seinstra, F. J. and Koelma, D.},
doi = {10.1002/cpe.765},
file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Seinstra, Koelma - 2004 - User transparency A fully sequential programming model for efficient data parallel image processing.pdf:pdf},
issn = {1532-0626},
journal = {Concurrency and Computation: Practice and Experience},
keywords = {Data parallel image processing,Performance evaluation,Software architecture design},
% mendeley-groups = {PhD/Parallel},
month = {5},
number = {6},
pages = {611--644},
% publisher = {John Wiley {\&} Sons, Ltd.},
title = {{User transparency: a fully sequential programming model for efficient data parallel image processing}},
url = {http://dx.doi.org/10.1002/cpe.765 http://doi.wiley.com/10.1002/cpe.765},
volume = {16},
year = {2004}
}

@article{Ragan-Kelley2017,
author = {Ragan-Kelley, Jonathan and Adams, Andrew and Sharlet, Dillon and Barnes, Connelly and Paris, Sylvain and Levoy, Marc and Amarasinghe, Saman and Durand, Fr{\'{e}}do},
doi = {10.1145/3150211},
file = {:C$\backslash$:/Users/J/AppData/Local/Mendeley Ltd./Mendeley Desktop/Downloaded/Ragan-Kelley et al. - 2017 - Halide.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
% mendeley-groups = {PhD/FP/SLR/CV},
month = {12},
number = {1},
pages = {106--115},
title = {{Halide}},
url = {http://dl.acm.org/citation.cfm?doid=3176926.3150211},
volume = {61},
year = {2017}
}

@inproceedings{Sanchez2012,
abstract = {Climacteric increases the risk of thrombotic events by alteration of plasmatic coagulation. Up to now, less is known about changes in platelet- (PMP) and endothelial cell-derived microparticles (EMP).},
author = {Sanchez, Ricardo M. and Rodriguez, Paul A.},
booktitle = {2012 IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP)},
doi = {10.1109/ICASSP.2012.6288187},
isbn = {978-1-4673-0046-9},
% issn = {15206149},
keywords = {Nonlinear filters,Parallel Algorithms},
% mendeley-groups = {PhD/Computer Vision},
month = {3},
pages = {1549--1552},
% pmid = {22627113},
publisher = {IEEE},
title = {{Bidimensional median filter for parallel computing architectures}},
url = {http://ieeexplore.ieee.org/document/6288187/},
year = {2012}
}

@article{Wu2011,
abstract = {In this paper, we propose an improved two-stage scheme for the removal of salt-and-pepper noise based on an efficient impulse detector and the edge-preserving total variation inpainting model. We test the proposed algorithm on the four images corrupted by salt-and-pepper noise with a wide range of noise levels varied from 10{\%} to 95{\%}, and compare it with the six other well known filters. Further, we evaluate quantitatively the performance of these filters with the peak signal-to-noise ratio (PSNR), the measure of structural similarity (SSIM) and the image enhancement factor (IEF). The experimental results have demonstrated that the proposed filter performs impressively in noise suppression and edge preservation. {\textcopyright} 2011 Elsevier B.V. All rights reserved.},
author = {Wu, Jian and Tang, Chen},
doi = {10.1016/j.patrec.2011.09.025},
% isbn = {0167-8655},
issn = {01678655},
journal = {Pattern Recognition Letters},
keywords = {Edge-preservation,Image denoising,Impulse noise,The two-stage scheme,Total variation inpainting},
% mendeley-groups = {PhD/Computer Vision},
month = {11},
number = {15},
pages = {1974--1981},
title = {{An efficient decision-based and edge-preserving method for salt-and-pepper noise removal}},
url = {http://linkinghub.elsevier.com/retrieve/pii/S0167865511002984},
volume = {32},
year = {2011}
}

@article{Gao2015,
abstract = {In this paper, an efficient three-stage scheme for the removal of salt {\&} pepper noise based on an efficient impulse detector, an adaptive mean-median filter and the total variation inpainting method was proposed. This approach removes salt {\&} pepper noise by detecting, estimating and modifying noisy pixels in an image. If a pixel is classified as noise, its intensity is first estimated by a mean-median filter; and then an accurate estimation is obtained through the use of the total variation inpainting method. Conversely, the pixel value is kept unchanged when it is classified as noise-free, yielding the quality of the restored image being well maintained. Experimental results demonstrate that the proposed three-stage approach can not only remove salt {\&} pepper impulse noise efficiently, but also preserve the detailed information of an image well.},
author = {Gao, Guorong and Liu, Yanping},
doi = {10.1016/j.ijleo.2014.11.004},
issn = {00304026},
journal = {Optik},
keywords = {Image denoising,Mean-median filter,Salt {\&} pepper noise,Total variation inpainting},
% mendeley-groups = {PhD/Computer Vision},
month = {2},
number = {4},
pages = {467--471},
title = {{An efficient three-stage approach for removing salt {\&} pepper noise from digital images}},
url = {https://linkinghub.elsevier.com/retrieve/pii/S0030402614013254},
volume = {126},
year = {2015}
}

@incollection{Boncelet2005,
abstract = {Noise is generally the unwanted component in an image. This chapter reviews commonly used image noise models. Some of these are naturally occurring (for example, the Gaussian noise), and some result from various processes (for example, quantization and transmission). The most common performance criterion is the mean squared error (MSE). The estimator that minimizes the MSE is called the minimum mean squared error estimator (MMSE). The chapter explains that noise occurs in images for many reasons. The Gaussian noise is a part of almost any signal. For example, the familiar white noise on a weak television station is well modeled as Gaussian. Because image sensors must count photons, especially in low light situations, and the number of photons counted is a random quantity, images often have photon counting noise. The grain noise in photographic films is sometimes modeled as Gaussian and sometimes as Poisson. Many images are corrupted by salt and pepper noise, as if someone had sprinkled black and white dots on the image. Other noises include quantization noise and speckle in coherent light situations. {\textcopyright} 2005 Elsevier Inc. All rights reserved.},
address = {Burlington},
author = {Boncelet, Charles},
booktitle = {Handbook of Image and Video Processing},
doi = {10.1016/B978-012119792-6/50087-5},
edition = {Second},
editor = {Bovik, A L},
isbn = {9780121197926},
% mendeley-groups = {PhD/Computer Vision},
pages = {397--409},
publisher = {Elsevier},
series = {Communications, Networking and Multimedia},
title = {{Image Noise Models}},
url = {http://www.sciencedirect.com/science/article/pii/B9780121197926500875 http://linkinghub.elsevier.com/retrieve/pii/B9780121197926500875},
year = {2005}
}

@article{Perrot2014,
abstract = {Median filtering is a well-known method used in a wide range of application frameworks as well as a standalone filter, especially for salt-and-pepper denoising. It is able to highly reduce the power of noise while minimizing edge blurring. Currently, existing algorithms and implementations are quite efficient but may be improved as far as processing speed is concerned, which has led us to further investigate the specificities of modern GPUs. In this paper, we propose the GPU implementation of fixed-size kernel median filters, able to output up to 1.85 billion pixels per second on C2070 Tesla cards. Based on a Branchless Vectorized Median class algorithm and implemented through memory fine tuning and the use of GPU registers, our median drastically outperforms existing implementations, resulting, as far as we know, in the fastest median filter to date.},
author = {Perrot, Gilles and Domas, St{\'{e}}phane and Couturier, Rapha{\"{e}}l},
doi = {10.1007/s11265-013-0799-2},
% isbn = {1433-7851},
issn = {1939-8018},
journal = {Journal of Signal Processing Systems},
keywords = {Filter,GPU,Median},
% mendeley-groups = {PhD},
month = {6},
number = {3},
pages = {185--190},
% pmid = {15340959},
title = {{Fine-tuned High-speed Implementation of a GPU-based Median Filter}},
url = {http://link.springer.com/10.1007/s11265-013-0799-2},
volume = {75},
year = {2014}
}

@article{Perreault2007,
abstract = {The median filter is one of the basic building blocks in many image processing situations. However, its use has long been hampered by its algorithmic complexity O(tau) of in the kernel radius. With the trend toward larger images and proportionally larger filter kernels, the need for a more efficient median filtering algorithm becomes pressing. In this correspondence, a new, simple, yet much faster, algorithm exhibiting O(1) runtime complexity is described and analyzed. It is compared and benchmarked against previous algorithms. Extensions to higher dimensional or higher precision data and an approximation to a circular kernel are presented, as well.},
author = {Perreault, Simon and Hebert, Patrick},
doi = {10.1109/TIP.2007.902329},
file = {:D$\backslash$:/Users/jcoo092/Writing/2018/IVCNZ18/References/Perreault, Hebert - Median Filtering in Constant Time - 2007.pdf:pdf},
% isbn = {1057-7149 (Print)},
issn = {1057-7149},
journal = {IEEE Transactions on Image Processing},
keywords = {Algorithms,Complexity theory,Image processing,Median filters},
% mendeley-groups = {PhD/Computer Vision},
month = {9},
number = {9},
pages = {2389--2394},
% pmid = {17784612},
title = {{Median Filtering in Constant Time}},
url = {http://nomis80.org/ctmf.html http://ieeexplore.ieee.org/document/4287006/},
volume = {16},
year = {2007}
}



% @article{Liu2021,
% abstract = {Multisets are widely used in membrane computing models such as cP systems. In this paper, we formally define the first-order one-way unification problem for labelled nested multisets, and propose a corresponding algorithm named LNMU (labelled nested multiset unification algorithm). LNMU is a nondeterministic algorithm that consists of eight transformations. Supported by a good strategy, LNMU can solve well-formed labelled nested multiset unification problems in linear time.},
% author = {Liu, Yezhou and Nicolescu, Radu and Sun, Jing},
% doi = {10.1007/s41965-021-00076-0},
% file = {:D\:/jarak/Documents/Mendeley Desktop/Liu, Nicolescu, Sun - 2021 - An efficient labelled nested multiset unification algorithm.pdf:pdf},
% isbn = {0123456789},
% issn = {2523-8906},
% journal = {Journal of Membrane Computing},
% keywords = {Algorithm,Membrane computing,Multiset,Unification,cP systems},
% % mendeley-groups = {PhD/P Systems},
% month = {5},
% //number = {0123456789},
% publisher = {Springer Singapore},
% title = {{An efficient labelled nested multiset unification algorithm}},
% //url = {https://doi.org/10.1007/s41965-021-00076-0 https://link.springer.com/10.1007/s41965-021-00076-0},
% year = {2021}
% }



% @incollection{Nicolescu2018,
% abstract = {We overview the current state of cP systems and illustrate it with a series of old and new examples, intentionally simple, but fundamental in their areas. cP systems -- i.e. P systems with compound terms -- share the fundamental features of traditional cell-like (tree-based) and tissue (graph-based) P systems: unlimited space and computing power, cells, nested cells, multisets, messages, rewriting rules, possibly running in maximal parallel modes. In contrast to traditional P systems, inner nested cells do not have their own rulesets. However, this restriction is usually more than compensated by their significant extensions: compound Prolog-like terms, high-level rules, control on incoming messages. Additionally, the same rulesets can run in either synchronous or asynchronous mode, without any syntactic change. cP systems have been successfully used to model quite a few fundamental and real-life problems, e.g. in NP complexity, data structures, graph theory, distributed algorithms, image processing. As trademark, cP models use fixed sized alphabets and crisp rulesets, independent of the problem size. The samples cover a wide variety of areas, such as arithmetic, list structures, summary statistics and sorting, asynchronous communications, {\$}{\$}$\backslash$mu {\$}{\$}{\$}\mu{\$}-recursive functions.},
% address = {Cham},
% author = {Nicolescu, Radu and Henderson, Alec},
% booktitle = {Enjoying Natural Computing: Essays Dedicated to Mario de Jes{\'{u}}s P{\'{e}}rez-Jim{\'{e}}nez on the Occasion of His 70th Birthday},
% doi = {10.1007/978-3-030-00265-7_17},
% editor = {Graciani, Carmen and Riscos-N{\'{u}}{\~{n}}ez, Agust{\'{i}}n and P{\u a}un, {\relax Gh}eorghe and Rozenberg, Grzegorz and Salomaa, Arto},
% file = {:D$\backslash$:/jarak/Documents/Nicolescu, Henderson - 2018 - An Introduction to cP Systems.pdf:pdf},
% isbn = {978-3-030-00265-7},
% % mendeley-groups = {PhD/P Systems},
% //number = {17},
% pages = {204--227},
% publisher = {Springer International Publishing},
% series = {Lecture Notes in Computer Science},
% title = {{An Introduction to cP Systems}},
% //url =     {https://doi.org/10.1007/978-3-030-00265-7{\_}17 http://link.springer.com/10.1007/978-3-030-00265-7{\_}17},
% volume = {11270},
% year = {2018}
% }

% @article{Diaz-Pernil2019,
% author = {D{\'{i}}az-Pernil, Daniel and Guti{\'{e}}rrez-Naranjo, Miguel A. and Peng, Hong},
% doi = {10.1007/s41965-018-00002-x},
% file = {:D$\backslash$:/jarak/Documents/D{\'{i}}az-Pernil, Guti{\'{e}}rrez-Naranjo, Peng - 2019 - Membrane computing and image processing a short survey.pdf:pdf},
% issn = {2523-8906},
% journal = {Journal of Membrane Computing},
% keywords = {Image processing,Membrane computing,P systems,image processing,membrane computing,p systems},
% % mendeley-groups = {PhD,PhD/P Systems},
% month = {3},
% number = {1},
% pages = {58--73},
% publisher = {Springer Singapore},
% title = {{Membrane computing and image processing: a short survey}},
% //url =     {https://doi.org/10.1007/s41965-018-00002-x http://link.springer.com/10.1007/s41965-018-00002-x},
% volume = {1},
% year = {2019}
% }

% @incollection{Henderson2019,
% address = {Berlin, Heidelberg},
% author = {Henderson, Alec and Nicolescu, Radu},
% booktitle = {Handbook of Natural Computing},
% doi = {10.1007/978-3-030-12797-8_12},
% editor = {Rozenberg, Grzegorz and B{\"{a}}ck, Thomas and Kok, Joost N.},
% file = {:D$\backslash$:/jarak/Documents/Henderson, Nicolescu - 2019 - Actor-Like cP Systems.pdf:pdf},
% isbn = {978-3-540-92909-3},
% keywords = {Actor mod,Distributed algorithms,Synchronous model,actor model,byzantine agreement,cp systems,distributed algorithms,eig trees,inter-cell parallelism,intra-cell parallelism,membrane computing,p systems,prolog terms and unification,synchronous model},
% pages = {160--187},
% publisher = {Springer Berlin Heidelberg},
% title = {{Actor-Like cP Systems}},
% //url =     {http://link.springer.com/10.1007/978-3-540-92910-9 http://link.springer.com/10.1007/978-3-030-12797-8\_12},
% year = {2019}
% }


% @incollection{Nicolescu2014,
% address = {Cham},
% annote = {From Duplicate 1 (Parallel Thinning with Complex Objects and Actors - Nicolescu, Radu)

% From Duplicate 1 (Parallel thinning with complex objects and actors - Nicolescu, Radu)

% ID: Nicolescu2014},
% author = {Nicolescu, Radu},
% booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
% doi = {10.1007/978-3-319-14370-5_21},
% editor = {Gheorghe, Marian and Rozenberg, Grzegorz and Salomaa, Arto and Sos{\'{i}}k, Petr and Zandron, Claudio},
% file = {:D$\backslash$:/jarak/Documents/Nicolescu - 2014 - Parallel Thinning with Complex Objects and Actors.pdf:pdf},
% isbn = {9783319143705},
% issn = {16113349},
% keywords = {Actor model,Complex objects,Generic rules,Guo-Hall algorithm,Image processing,Inter-cell parallelism,Intra-cell parallelism,Membrane computing,Message-based,P systems,Parallel and concurrent models,Prolog terms,Synchronous and asynchronous models,Termination detection,complex objects,els,generic rules,guo-hall algorithm,image processing,inter-cell parallelism,intra-cell parallelism,membrane computing,p systems,parallel and concurrent mod-,prolog terms,synchronous and asynchronous models,termination detection},
% % mendeley-groups = {PhD/P Systems},
% pages = {330--354},
% publisher = {Springer International Publishing},
% title = {{Parallel Thinning with Complex Objects and Actors}},
% //url =     {http://dx.doi.org/10.1007/978-3-319-14370-5{\_}21 http://link.springer.com/10.1007/978-3-319-14370-5{\_}21},
% volume = {8961},
% year = {2014}
% }

% @incollection{Nicolescu2015,
% address = {Cham},
% annote = {ID: Nicolescu2015},
% author = {Nicolescu, Radu},
% booktitle = {Membrane Computing: 16th International Conference, CMC 2015, Valencia, Spain, August 17-21, 2015, Revised Selected Papers},
% doi = {10.1007/978-3-319-28475-0_22},
% editor = {Rozenberg, Grzegorz and Salomaa, Arto and Sempere, Jos{\'{e}} M and Zandron, Claudio},
% isbn = {978-3-319-28475-0},
% % mendeley-groups = {PhD/P Systems},
% pages = {321--337},
% publisher = {Springer International Publishing},
% title = {{Structured Grid Algorithms Modelled with Complex Objects}},
% //url =     {http://link.springer.com/10.1007/978-3-319-28475-0{\_}22},
% year = {2015}
% }

@inreference{Fisher2016,
author = {Fisher, Robert B. and Breckon, T. P. and Dawson-Howe, K. and Fitzgibbon, A. and Robertson, C. and Trucco, E. and Williams, C. K. I.},
booktitle = {Dictionary of Computer Vision and Image Processing},
chapter = {M},
doi = {10.1002/9781119286462.ch14},
editor = {Fisher, Robert B. and Breckon, T. P. and Dawson-Howe, K. and Fitzgibbon, A. and Robertson, C. and Trucco, E. and Williams, C. K. I.},
publisher = {John Wiley \& Sons, Ltd},
title = {{Median Smoothing}},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/9781119286462.ch14},
year = {2016}
}

% @inproceedings{Cooper2018,
% abstract = {Many approaches to simplifying/enabling the use of parallelism in programming tasks exist. A substantial number of those concentrate solely either on data-parallelism or fork-join-based task-parallelism. Concurrent ML is an alternative approach based around the concept of lightweight individual sub-processes synchronously exchanging messages. This work explores the usefulness of the CML approach in image processing, by applying it to the basic median filter operation and contrasting it with other simple implementations. The results strongly suggest that it is a comparatively poor fit to such an operation, with the one slight advantage of apparently having better peak memory requirements. It is not clear, however, how efficient are either the algorithm implementation or the library it is based on.},
% address = {Auckland, New Zealand},
% author = {Cooper, James},
% booktitle = {2018 International Conference on Image and Vision Computing New Zealand (IVCNZ)},
% doi = {10.1109/IVCNZ.2018.8634712},
% //file = {:D\:/jarak/Documents/Mendeley Desktop/Cooper - 2019 - Concurrent ML as an Alternative Parallel Programming Style for Image Processing.pdf:pdf},
% isbn = {978-1-7281-0125-5},
% issn = {21512205},
% keywords = {Concurrent ML,F\#,Hopac,Image processing,Median filter},
% month = {11},
% pages = {1--6},
% publisher = {IEEE},
% title = {{Concurrent ML as an Alternative Parallel Programming Style for Image Processing}},
% //url = {https://ieeexplore.ieee.org/document/8634712/},
% volume = {2018-Novem},
% year = {2018}
% }

@unpublished{Cooper2021,
author = {Cooper, James and Nicolescu, Radu},
% issn = {2523-8906},
% journal = {Journal of Membrane Computing},
% publisher = {Springer Singapore},
title = {Neighbourhood Message Passing on a Lattice with cP systems:  Part One},
year = {2021},
pubstate = {Submitted for publication},
% notes = {In submission},
}

@book{Gimelfarb2018,
author = {Gimel'farb, Georgy and Delmas, Patrice},
doi = {10.1142/q0173},
isbn = {978-1-78634-581-3},
% issn = {2516-6239},
% month = {10},
publisher = {World Scientific (Europe)},
series = {Primers in Electronics and Computer Science},
title = {{Image Processing and Analysis:  A Primer}},
url = {https://www.worldscientific.com/worldscibooks/10.1142/q0173},
volume = {03},
year = {2019}
}

% @techreport{Paun1999a,
% abstract = {P systems are parallel Molecular Computing models based on processing multisets of objects in cell-like membrane structures. Various variants were already shown to be computationally universal, equal in power to Turing machines. In this paper one proposes a class of P systems whose membranes are the main active components, in the sense that they directly mediate the evolution and the communication of objects. Moreover, the membranes can multiply themselves by division. We prove that this variant is not only computationally universal, but also able to solve NP complete problems in polynomial (actually, linear) time. We exemplify this assertion with the well-known SAT problem.},
% address = {Auckland},
% author = {Păun, Gheorghe},
% file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Păun - 1999 - P systems with active membranes Attacking NP-Complete problems.pdf:pdf},
% institution = {University of Auckland},
% mendeley-groups = {PhD/P Systems,PhD},
% pages = {1--17},
% series = {CDMTCS},
% title = {{P systems with active membranes: Attacking NP-Complete problems}},
% url = {https://www.cs.auckland.ac.nz/research/groups/CDMTCS/researchreports/index.php?author{\&}open=177},
% year = {1999}
% }

% @article{Paun1999a,
%   author  = {{Gh}eorghe P{\u{a}}un},
%   title   = {P Systems with Active Membranes: Attacking NP-Complete Problems},
%   journal = {Journal of Automata, Languages and Combinatorics},
%   volume  = {6},
%   number  = {1},
%   pages   = {75--90},
%   year    = {2001},
%   url     = {https://doi.org/10.25596/jalc-2001-075},
%   doi     = {10.25596/jalc-2001-075}
% }

% @article{Henderson2020,
% abstract = {There have been a few NP-hard problems solved using cP systems including the travelling salesman problem. However, these problems are typically in NP rather than higher in the polynomial time hierarchy. In this paper, we solve QSAT (also known as TQBF), which is a well-known PSPACE-complete problem. Compared to other extant confluent P systems solutions, our deterministic cP solution only uses a small constant number of custom alphabet symbols (19), a small constant number of rules (10) and a small constant upper limit of membrane nesting depth (6), independent of the problem size.},
% author = {Henderson, Alec and Nicolescu, Radu and Dinneen, Michael J.},
% doi = {10.1007/s41965-020-00064-w},
% file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Henderson, Nicolescu, Dinneen - 2020 - Solving a PSPACE-complete problem with cP systems.pdf:pdf},
% issn = {2523-8906},
% journal = {Journal of Membrane Computing},
% % mendeley-groups = {PhD/P Systems},
% month = {12},
% number = {4},
% pages = {311--322},
% title = {{Solving a PSPACE-complete problem with cP systems}},
% url = {https://doi.org/10.1007/s41965-020-00064-w http://link.springer.com/10.1007/s41965-020-00064-w},
% volume = {2},
% year = {2020}
% }

% @article{Sosik2003,
% abstract = {We study the computational power of cell division operations in the formal framework of P systems, a mathematical model of cell-like membrane structure with regulated transport of objects (molecules) through membranes. We show that a uniform family of P systems with active membranes and 2-division is able to solve the well-known PSPACE-complete problem QBF in linear time. This result implies that such a family of P systems modelling cell division is at least as powerful as so-called Second Machine Class computers. The Second Machine Class, containing most of the fundamental parallel computer models such as parallel RAM machines of types SIMD and MIMD, vector machines and others, is characterized by using an exponential amount of resources (processing units) with respect to the computing time. {\textcopyright} 2003 Kluwer Publishers.},
% annote = {ID: Sos{\'{i}}k2003},
% author = {Sos{\'{i}}k, Petr},
% doi = {10.1023/A:1025401325428},
% issn = {15677818},
% journal = {Natural Computing},
% keywords = {Membrane computing,P system,Second Machine Class},
% % mendeley-groups = {PhD/P Systems},
% number = {3},
% pages = {287--298},
% title = {{The computational power of cell division in P systems: Beating down parallel computers?}},
% url = {http://dx.doi.org/10.1023/A:1025401325428},
% volume = {2},
% year = {2003}
% }

@article{Sosik2019,
abstract = {In the field of membrane computing, a great attention is traditionally paid to the results demonstrating a theoretical possibility to solve NP-complete problems in polynomial time by means of various models of P systems. A bit less common is the fact that almost all models of P systems with this capability are actually stronger: some of them are able to solve PSPACE-complete problems in polynomial time, while others have been recently shown to characterize the class P{\#}P (which is conjectured to be strictly included in PSPACE). A large part of these results has appeared quite recently. In this survey, we focus on strong models of membrane systems which have the potential to solve hard problems belonging to classes containing NP. These include P systems with active membranes, P systems with proteins on membranes and tissue P systems, as well as P systems with symport/antiport and membrane division and, finally, spiking neural P systems. We provide a survey of computational complexity results of these membrane models, pointing out some features providing them with their computational strength. We also mention a sequence of open problems related to these topics.},
author = {Sos{\'{i}}k, Petr},
doi = {10.1007/s41965-019-00017-y},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Sos{\'{i}}k - 2019 - P systems attacking hard problems beyond NP a survey.pdf:pdf},
issn = {2523-8906},
journal = {Journal of Membrane Computing},
keywords = {Computational complexity,Membrane computing,NP,P system,PP,PSPACE},
% mendeley-groups = {PhD/P Systems},
month = {9},
number = {3},
pages = {198--208},
publisher = {Springer Singapore},
title = {{P systems attacking hard problems beyond NP: a survey}},
url = {https://doi.org/10.1007/s41965-019-00017-y http://link.springer.com/10.1007/s41965-019-00017-y},
volume = {1},
year = {2019}
}

% @article{Cooper2019,
% abstract = {The Hamiltonian Cycle Problem (HCP) and Travelling Salesman Problem (TSP) are long-standing and well-known NP-hard problems. The HCP is concerned with finding paths through a given graph such that those paths visit each node exactly once after the start, and end where they began (i.e., Hamiltonian cycles). The TSP builds on the HCP and is concerned with computing the lowest cost Hamiltonian cycle on a weighted (di)graph. Many solutions to these problems exist, including some from the perspective of P systems. For the TSP however, almost all these papers have combined membrane computing with other approaches for approximate solution algorithms, which is surprising given the plethora of P systems solutions to the HCP. A recent paper presented a brute-force style P systems solution to the TSP with a time complexity of O(n2), exploiting the ability of P systems to reduce time complexity in exchange for space complexity, but the resultant system had a fairly high number of rules, around 50. Inspired by this paper, and seeking a more concise representation of an exact brute-force TSP algorithm, we have devised a P systems algorithm based on cP systems (P systems with Complex Objects) which requires five rules and takes n + 3 steps. We first provide some background on cP systems and demonstrate a fast new cP systems method to find the minimum of a multiset, then describe our solution to the HCP, and build on that for our TSP algorithm. This paper describes said algorithms, and provides an example application of our TSP algorithm to a given graph and a digraph variant.},
% author = {Cooper, James and Nicolescu, Radu},
% doi = {10.3233/FI-2019-1760},
% editor = {Pan, Linqiang and P{\'{e}}rez-Jim{\'{e}}nez, Mario J. and Zhang, Gexiang},
% issn = {01692968},
% journal = {Fundamenta Informaticae},
% keywords = {CP systems,Hamiltonian Cycle Problem,P systems,Prolog terms and unification,Travelling Salesman Problem},
% % mendeley-groups = {PhD},
% month = {1},
% number = {2-3},
% pages = {157--180},
% title = {{The Hamiltonian cycle and travelling salesman problems in cP systems}},
% url = {https://www.medra.org/servlet/aliasResolver?alias=iospress{\&}doi=10.3233/FI-2019-1760},
% volume = {164},
% year = {2019}
% }

@article{Song2015b,
abstract = {P systems are computing models inspired by some basic features of biological membranes. In this work, membrane division, which provides a way to obtain an exponential workspace in linear time, is introduced into (cell-like) P systems with communication (symport/antiport) rules, where objects are never modified but they just change their places. The computational efficiency of this kind of P systems is studied. Specifically, we present a (uniform) linear time solution to the NP-complete problem, Subset Sum by using division rules for elementary membranes and communication rules of length at most 3. We further prove that such P system allowing division rules for non-elementary membranes can efficiently solve the PSPACE-complete problem, QSAT in a uniform way.},
author = {Song, Bosheng and P{\'{e}}rez-Jim{\'{e}}nez, Mario J. and Pan, Linqiang},
doi = {10.1016/j.biosystems.2015.03.002},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Song, P{\'{e}}rez-Jim{\'{e}}nez, Pan - 2015 - Efficient solutions to hard computational problems by P systems with symportantiport rules and membran.pdf:pdf},
issn = {03032647},
journal = {Biosystems},
keywords = {Cell-like P system,Membrane division,QSAT problem,Subset Sum problem,Symport/Antiport rule},
% mendeley-groups = {PhD/P Systems},
month = {4},
pages = {51--58},
pmid = {25802073},
publisher = {Elsevier Ireland Ltd},
title = {{Efficient solutions to hard computational problems by P systems with symport/antiport rules and membrane division}},
url = {http://dx.doi.org/10.1016/j.biosystems.2015.03.002 https://linkinghub.elsevier.com/retrieve/pii/S0303264715000350},
volume = {130},
year = {2015}
}

@article{Pan2016,
abstract = {In spite of the fact that many ways of using the evolution rules in a P system were already investigated, there is still a case, which we call the flat maximal parallelism, which appeared in several papers, but which deserves a more careful attention: in each step, in each membrane, a maximal set of applicable rules is chosen and each rule in the set is applied exactly once. In this work, flat maximal parallelism is studied for non-cooperating P systems with promoters. Specifically, we prove that non-cooperating P systems with at most one promoter associated with any rule, working in the flat maximally parallel way, are Turing universal (the Turing universality of such P systems is open if they work in the maximally parallel way). Moreover, a uniform solution to the SAT problem is provided by using non-cooperating P systems with promoters and membrane division, working in the flat maximal parallel way.},
author = {Pan, Linqiang and Păun, Gheorghe and Song, Bosheng},
doi = {10.1016/j.tcs.2015.10.027},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Pan, Păun, Song - 2016 - Flat maximal parallelism in P systems with promoters.pdf:pdf},
% isbn = {2012014213008},
issn = {03043975},
journal = {Theoretical Computer Science},
keywords = {Membrane computing,P system,Parallelism,Universality},
% mendeley-groups = {PhD/P Systems},
month = {4},
pages = {83--91},
title = {{Flat maximal parallelism in P systems with promoters}},
url = {https://linkinghub.elsevier.com/retrieve/pii/S0304397515009202},
volume = {623},
year = {2016}
}

@incollection{Alhazov2009,
abstract = {Membrane computing is a formal framework of distributed parallel multiset processing. Due to massive parallelism and exponential space some intractable computational problems can be solved by P systems with active membranes in a polynomial number of steps. In this paper we generalize this approach from decisional problems to the computational ones, by providing a solution of a {\#}P-complete problem, namely to compute the permanent of a binary matrix. The implication of this result to the PP complexity class is discussed and compared to known results about NP∈ ∈co∈-∈ NP. {\textcopyright} 2009 Springer Berlin Heidelberg.},
author = {Alhazov, Artiom and Burtseva, Liudmila and Cojocaru, Svetlana and Rogozhin, Yurii},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-540-95885-7_8},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Alhazov et al. - 2009 - Solving PP-Complete and {\#}P-Complete Problems by P Systems with Active Membranes.pdf:pdf},
issn = {03029743},
% mendeley-groups = {PhD/P Systems},
pages = {108--117},
title = {{Solving PP-Complete and {\#}P-Complete Problems by P Systems with Active Membranes}},
url = {http://link.springer.com/10.1007/978-3-540-95885-7{\_}8},
volume = {5391 LNCS},
year = {2009}
}

% @book{Gustafson2017,
% abstract = {Written by one of the foremost experts in high-performance computing and the inventor of Gustafson's Law, The End of Error: Unum Computing explains a new approach to computer arithmetic: the universal number (unum). The unum encompasses all IEEE floating-point formats as well as fixed-point and exact integer arithmetic. This new number type obtains more accurate answers than floating-point arithmetic yet uses fewer bits in many cases, saving memory, bandwidth, energy, and power.},
% address = {New York, New York, USA},
% author = {Gustafson, John L.},
% booktitle = {The End of Error},
% doi = {10.1201/9781315161532},
% isbn = {9781315161532},
% month = {6},
% pages = {1--416},
% publisher = {Chapman and Hall/CRC},
% title = {{The End of Error}},
% url = {https://www.taylorfrancis.com/books/9781315161532},
% year = {2017}
% }

@inproceedings{Powers1991,
abstract = {This paper introduces a parallel sorting algorithm based on QuickSort and having an n-input, n- processor, time complexity of O(log n) exhibited using a CRCW PRAM model. Although existing algorithms of similar complexity are known, this approach leads to a family of algorithms with a considerably lower constant. It is also significant in its close relationship to a standard sequential algorithm.},
address = {Novosibirsk, Russia},
author = {Powers, David M. W.},
booktitle = {PROCEEDINGS OF INTERNATIONAL CONFERENCE ON PARALLEL COMPUTING TECHNOLOGIES. NOVOSIBIRSK.},
file = {:D\:/jarak/Documents/Mendeley Desktop/Powers - 1991 - Parallelized QuickSort and RadixSort with Optimal Speedup.pdf:pdf},
pages = {167--176},
publisher = {World Scientific},
title = {{Parallelized QuickSort and RadixSort with Optimal Speedup}},
url = {https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.9071},
year = {1991}
}

@incollection{Ceterchi2010,
address = {New York, New York, USA},
author = {Ceterchi, Rodica and Sburlan, Dragoş},
booktitle = {Oxford Handbook of Membrane Computing},
chapter = {22},
editor = {Păun, Gheorghe and Rozenberg, Grzegorz and Salomaa, Arto},
isbn = {978-0-19-955667-0},
% mendeley-groups = {PhD/P Systems},
pages = {553--583},
publisher = {Oxford University Press, Inc.},
title = {{Membrane Computing and Computer Science}},
year = {2010}
}

@inproceedings{Arulanandham2002,
abstract = {In this paper, we implement Bead–Sort, a natural sorting algorithm that we introduced in [1], with the new, biochemically inspired P systems. In Bead–Sort, positive integers are represented by a set of beads (like those used in an Abacus). The beads representing integers to be sorted are allowed to slide through the rods of the Abacus. In this process, the smaller “numbers” always emerge above the larger ones and this creates a natural comparison and thus a natural sorting action. This natural sorting phenomenon is “implemented” with a special type of P system—a tissue P system that computes by means of communication (using symport/antiport rules) only. Beads are represented by objects placed within membranes of a tissue P system; a rod is represented by a ‘group' of membranes that can communicate with one another by means of symport/antiport rules. The “flow” of objects between the group of membranes representing a rod (using communication rules) reflects the actual flow of beads in the physical system.},
author = {Arulanandham, Joshua J.},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/3-540-45833-6_10},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Arulanandham - 2002 - Implementing bead-sort with P systems.pdf:pdf},
isbn = {3540443118},
% issn = {16113349},
% mendeley-groups = {PhD/P Systems},
number = {3},
pages = {115--125},
title = {{Implementing bead-sort with P systems}},
url = {http://link.springer.com/10.1007/3-540-45833-6{\_}10},
volume = {2509},
year = {2002}
}

@incollection{Alhazov2007,
abstract = {The topic of this chapter is application of P systems for sorting problems, i.e., constructing sorting algorithms for various variants of P systems. Traditional studies of sorting assume a constant time for comparing two numbers and compute the time complexity with respect to the number of components of a vector to be sorted. Here we assume the number of components to be a fixed number k, and study various algorithms with distinct generative features based on different models of P systems, and their time complexity with respect to the maximal number, or to their sum. Massively parallel computations that can be realized within the framework of P systems offer a premise to major improvements of the classical integer sorting problems. Despite this important characteristic we will see that, depending on the model used, the massive parallelism feature cannot be always used, and so, some results will have the complexity {\^{a}}€{\oe}comparable{\^{a}}€ with the classical integer sorting algorithms. Still, computing an (ordered) word from an (unordered) multiset can be a goal not only for computer science but also, at least, for bio-synthesis (separating mixed objects according to some characteristics). Here, we will pass from ranking algorithms that, starting with numbers represented as multisets, produce symbols in an order, to effective sorting algorithms.},
address = {Berlin, Heidelberg},
author = {Alhazov, Artiom and Sburlan, Dragoş},
booktitle = {Applications of Membrane Computing},
doi = {10.1007/3-540-29937-8_8},
editor="Ciobanu, Gabriel
and P{\u{a}}un, Gheorghe
and P{\'e}rez-Jim{\'e}nez, Mario J.",
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Alhazov, Sburlan - 2007 - Static Sorting P Systems.pdf:pdf},
% mendeley-groups = {PhD/P Systems},
pages = {215--252},
publisher = {Springer Berlin Heidelberg},
title = {{Static Sorting P Systems}},
url = {http://link.springer.com/10.1007/3-540-29937-8{\_}8},
year = {2007}
}

@incollection{Gheorghe2017,
abstract = {A kernel P system (kP system, for short) integrates in a coherent and elegant manner many of the P system features most successfully used for modelling various applications and, consequently, it provides a framework for analyzing these models. In this paper, we illustrate the modelling capacity of kernel P systems by providing a number of kP system models for sorting algorithms. Furthermore, the problem of testing systems modelled as kP systems is also discussed and a test generation method based on automata is proposed. We also demonstrate how formal verification can be used to validate that the given models work as desired.},
author = {Gheorghe, Marian and Ceterchi, Rodica and Ipate, Florentin and Konur, Savas},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-54072-6_15},
editor="Leporati, Alberto
and Rozenberg, Grzegorz
and Salomaa, Arto
and Zandron, Claudio",
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Gheorghe et al. - 2017 - Kernel P Systems Modelling, Testing and Verification - Sorting Case Study.pdf:pdf},
isbn = {9783319540719},
% issn = {16113349},
% mendeley-groups = {PhD/P Systems},
pages = {233--250},
title = {{Kernel P Systems Modelling, Testing and Verification - Sorting Case Study}},
url = {http://link.springer.com/10.1007/978-3-319-54072-6{\_}15},
volume = {10105 LNCS},
year = {2017}
}

@incollection{Metta2015,
abstract = {This paper introduces and makes use of spiking neural P systems with anti-spikes and rules on synapses to sort integers. Here we discuss two types of sorting, bead sort and bitonic sort to sort integers.},
address = {Cham},
author = {Metta, Venkata Padmavati and Kelemenov{\'{a}}, Alica},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-319-28475-0_20},
editor = {Rozenberg, Grzegorz and Salomaa, Arto and Sempere, Jos{\'{e}} M. and Zandron, Claudio},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Metta, Kelemenov{\'{a}} - 2015 - Sorting Using Spiking Neural P Systems with Anti-spikes and Rules on Synapses.pdf:pdf},
isbn = {9783319284743},
% issn = {16113349},
% mendeley-groups = {PhD/P Systems},
pages = {290--303},
publisher = {Springer International Publishing},
series = {Lecture Notes in Computer Science},
title = {{Sorting Using Spiking Neural P Systems with Anti-spikes and Rules on Synapses}},
url = {http://link.springer.com/10.1007/978-3-319-28475-0 http://link.springer.com/10.1007/978-3-319-28475-0{\_}20},
volume = {9504},
year = {2015}
}

@incollection{Yan2019,
abstract = {The FP-growth is an effective method of mining frequent itemsets to find association rules. But this algorithm scans the database twice to create a FP-tree. This process reduces the efficiency of the algorithm. An improved method, the TPPIIFP-growth algorithm, is presented and uses two-dimensional vector table and tissue-like P systems with promoters and inhibitors to improve the original algorithm. While reducing the scanning, using the flat maximally parallel reduces the time complexity. And this method can be applied to other similar algorithms.},
author = {Yan, Shuo and Xue, Jie and Liu, Xiyu},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-030-12797-8_18},
editor="Hinze, Thomas
and Rozenberg, Grzegorz
and Salomaa, Arto
and Zandron, Claudio",
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Yan, Xue, Liu - 2019 - An Improved Quicksort Algorithm Based on Tissue-Like P Systems with Promoters.pdf:pdf},
isbn = {9783030151263},
% issn = {16113349},
keywords = {Data mining,FP-growth algorithm,Frequent itemsets,IFP-growth algorithm,Tissue-like P systems},
% mendeley-groups = {PhD/P Systems},
pages = {258--274},
publisher = {Springer International Publishing},
title = {{An Improved Quicksort Algorithm Based on Tissue-Like P Systems with Promoters}},
url = {http://dx.doi.org/10.1007/978-3-030-12797-8{\_}18 http://link.springer.com/10.1007/978-3-030-12797-8{\_}18},
volume = {11354 LNCS},
year = {2019}
}

% @mvbook{Knuth1998,
% address = {Boston, MA, USA},
% author = {Knuth, Donald E.},
% booktitle = {Sorting and Searching},
% edition = {2},
% isbn = {978-0-201-89685-5},
% % maintitle = {The Art of Computer Programming},
% publisher = {Addison Wesley Longman Publishing Co., Inc.},
% series = {Addison-Wesley series in computer science and information processing},
% % title = {The Art of Computer Programming,  Volume 3: (2nd Ed.) Sorting and Searching},
% % title = {Sorting and Searching},
% subtitle = {Sorting and Searching},
% title = {The Art of Computer Programming},
% volume = {3},
% year = {1998},
% }

@book{Knuth1998,
address = {Boston, MA, USA},
author = {Knuth, Donald E.},
% booktitle = {Sorting and Searching},
edition = {2},
isbn = {978-0-201-89685-5},
maintitle = {The Art of Computer Programming},
publisher = {Addison Wesley Longman Publishing Co., Inc.},
series = {Addison-Wesley series in computer science and information processing},
% title = {The Art of Computer Programming,  Volume 3: (2nd Ed.) Sorting and Searching},
title = {Sorting and Searching},
% subtitle = {Sorting and Searching},
% title = {The Art of Computer Programming},
volume = {3},
year = {1998},
}

@article{Lee1995,
abstract = {A multiway merge sorting network is presented, which generalizes the technique used in the odd-even merge sorting network. The merging network described here is composed of m k-way mergers and a combining network. It arranges k ordered lists of length n each into one ordered lists in T(k) + [logmn] [log2 k] [log2 m] steps, where T(k) is the number of steps needed to sort k keys in order; and k and m are any integers no longer restricted to 2. {\textcopyright} 1994 IEEE},
author = {Lee, De-Lei and Batcher, Kenneth E.},
doi = {10.1109/71.342136},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Lee, Batcher - 1995 - A multiway merge sorting network.pdf:pdf},
issn = {10459219},
journal = {IEEE Transactions on Parallel and Distributed Systems},
keywords = {Sorting networks,multiway merge,odd-even merge,parallel processing},
% mendeley-groups = {PhD/Parallel},
month = {2},
number = {2},
pages = {211--215},
title = {{A multiway merge sorting network}},
url = {http://ieeexplore.ieee.org/document/342136/},
volume = {6},
year = {1995}
}

@inbook{JaJa2011,
abstract = {The Parallel Random Access Machine (PRAM) is an abstract model for parallel computation which assumes that all the processors operate synchronously under a single clock and are able to randomly access a large shared memory. In particular, a processor can execute an arithmetic, logic, or memory access operation within a single clock cycle.},
address = {Boston, MA},
author = {JaJa, Joseph F.},
booktitle = {Encyclopedia of Parallel Computing},
doi = {10.1007/978-0-387-09766-4_23},
editor = {Padua, David},
isbn = {978-0-387-09766-4},
% mendeley-groups = {PhD},
pages = {1608--1615},
publisher = {Springer US},
title = {{PRAM (Parallel Random Access Machines)}},
url = {https://doi.org/10.1007/978-0-387-09766-4{\_}23 http://link.springer.com/10.1007/978-0-387-09766-4{\_}23},
year = {2011}
}

@inbook{Akl2011,
address = {Boston, MA},
author = {Akl, Selim G.},
booktitle = {Encyclopedia of Parallel Computing},
doi = {10.1007/978-0-387-09766-4_124},
% edition = {2011},
editor = {Padua, David},
isbn = {978-0-387-09766-4},
% mendeley-groups = {PhD},
pages = {139--146},
publisher = {Springer US},
title = {{Bitonic Sort}},
url = {https://doi.org/10.1007/978-0-387-09766-4{\_}124 http://link.springer.com/10.1007/978-0-387-09766-4{\_}124},
year = {2011}
}

@incollection{Sanders1997,
abstract = {Parallel quicksort is known as a very scalable parallel sorting algorithm. However, most actual implementations lmve been limited to basic versions which suffer from irregular communication patterns and load imbalance. We have implemented a high performance variant of paraUel quicksort which incorporates the following optimizations: Stop the recursion at the right time, sort locally first, use accurate yet efficient pivot selection strategies, streamline communication patterns, use locality preserving processor indexing schemes and work with multiple pivots at once. It turns out to be among the best practical sorting methods. It is about three times faster than the basic algorithm and achieves a speedup of 810 on a 1024 processor Parsytec GCel for the NAS parallel sorting benchmark of size 224. The optimized algorithm can also be shown to be asymptotically optimal on meshes.},
author = {Sanders, Peter and Hansch, Thomas},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/3-540-63138-0_2},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Sanders, Hansch - 1997 - Efficient massively parallel quicksort.pdf:pdf},
isbn = {3540631380},
issn = {16113349},
keywords = {Implementation of parallel quicksort,Irregular communication patterns,Locality preserving indexing schemes,LooA balancing,Sorting with multiple pivots},
% mendeley-groups = {PhD/Parallel},
pages = {13--24},
title = {{Efficient massively parallel quicksort}},
url = {http://link.springer.com/10.1007/3-540-63138-0{\_}2},
volume = {1253},
year = {1997}
}

@article{Chlebus1991,
abstract = {A parallel version of quicksort on a CRCW PRAM is developed. The algorithm uses n processors and a linear space to sort n keys in the expected time O(log n) with large probability. {\textcopyright} 1991.},
author = {Chlebus, Bogdan S. and Vrťo, Imrich},
doi = {10.1016/0743-7315(91)90040-G},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Chlebus, Vrťo - 1991 - Parallel quicksort.pdf:pdf},
issn = {07437315},
journal = {Journal of Parallel and Distributed Computing},
% mendeley-groups = {PhD/Parallel},
month = {4},
number = {4},
pages = {332--337},
title = {{Parallel quicksort}},
url = {https://linkinghub.elsevier.com/retrieve/pii/074373159190040G},
volume = {11},
year = {1991}
}

@article{Manca2016,
abstract = {Summary Sorting is a very important task in computer science and becomes a critical operation for programs making heavy use of sorting algorithms. General-purpose computing has been successfully used on Graphics Processing Units (GPUs) to parallelize some sorting algorithms. Two GPU-based implementations of the quicksort were presented in literature: the GPU-quicksort, a compute-unified device architecture (CUDA) iterative implementation, and the CUDA dynamic parallel (CDP) quicksort, a recursive implementation provided by NVIDIA Corporation. We propose CUDA-quicksort an iterative GPU-based implementation of the sorting algorithm. CUDA-quicksort has been designed starting from GPU-quicksort. Unlike GPU-quicksort, it uses atomic primitives to perform inter-block communications while ensuring an optimized access to the GPU memory. Experiments performed on six sorting benchmark distributions show that CUDA-quicksort is up to four times faster than GPU-quicksort and up to three times faster than CDP-quicksort. An in-depth analysis of the performance between CUDA-quicksort and GPU-quicksort shows that the main improvement is related to the optimized GPU memory access rather than to the use of atomic primitives. Moreover, in order to assess the advantages of using the CUDA dynamic parallelism, we implemented a recursive version of the CUDA-quicksort. Experimental results show that CUDA-quicksort is faster than the CDP-quicksort provided by NVIDIA, with better performance achieved using the iterative implementation.},
author = {Manca, Emanuele and Manconi, Andrea and Orro, Alessandro and Armano, Giuliano and Milanesi, Luciano},
doi = {10.1002/cpe.3611},
file = {:D$\backslash$:/Users/jcoo092/Documents/Mendeley Desktop/Manca et al. - 2016 - CUDA-quicksort an improved GPU-based implementation of quicksort.pdf:pdf},
issn = {15320626},
journal = {Concurrency and Computation: Practice and Experience},
keywords = {CUDA,GPU,high performance computing,quick sort},
% mendeley-groups = {PhD/Parallel},
month = {jan},
number = {1},
pages = {21--43},
title = {{CUDA-quicksort: an improved GPU-based implementation of quicksort}},
url = {https://onlinelibrary.wiley.com/doi/10.1002/cpe.3611},
volume = {28},
year = {2016}
}
