\section{Background}

The \gls{hpp} is a long-standing, well-known computationally difficult (NP-hard) problem in Computer Science and related fields.  The problem consists of trying to determine whether for a given graph (digraph) there exists a traversal of the graph in which each node (vertex) is visited exactly once.  Depending on the particular problem at hand, the starting and/or ending node may or may not be arbitrarily selected.  Intrinsically linked, and arguably more useful, is \emph{describing} such a Hamiltonian path --- describing one proves the existence of it, and allows for its potential use in practical applications.  The \gls{hcp} is a closely related variant, in which the Hamiltonian path must also be a cycle, \ie{} the final node (vertex) in the path is the same as the starting one, such that every node (vertex) is visited exactly once after the start.

The \gls{tsp} is an extension to the \gls{hcp}, and is about finding the minimum cost Hamiltonian cycle in a \emph{weighted} (di)graph.  It has been described as analogous to finding the shortest route for a travelling salesman to visit multiple cities in one trip (whence the name).  The problem is arguably the most useful of the three to solve in practice, and has been studied extensively, spawning many papers, dissertations and books on the topic (\eg{} \cite{Smith2017,Ezugwu2017,Cook2012,Applegate2006} among many, many others).  A variety of sophisticated algorithms have been developed to solve the problem efficiently, in either the exact or approximate case.  This \lcnamecref{chap:tsp} does not seek to overturn this prior body of work.  Instead, it seeks to address the problem from a \gls{cps} perspective.  This \lcnamecref{chap:tsp} discusses the \emph{optimisation} form of the \gls{tsp}, which is NP-Hard but not NP-Complete, and not the \emph{decision} form of the \gls{tsp}, which is NP-Complete.\footnote{See for example \url{https://www.ibm.com/developerworks/community/blogs/jfp/entry/no_the_tsp_isn_t_np_complete?lang=en} for an interesting but informal discussion of the difference.}

While there had been a handful of approximate solutions to the \gls{tsp} using \gls{mc} in the past (see \vref{sec:tsp:comparison}), \citeauthor{Guo2017} presented the first known paper on solving the \gls{tsp} in the exact case using \gls{clps} \cite{Guo2017}, requiring roughly 50 rules.  By exploiting the property of many \gls{ps} variants that time complexity can often be exchanged for space and/or processing complexity \cite{Paun1999,Paun2002a,Jimenez2003,Song2017}, the authors derived a \gls{ps} algorithm that can solve the \gls{tsp} in \bigoh{n^2} time.

Inspired by \cite{Guo2017}, but aiming for a more compact solution, this \lcnamecref{chap:tsp} derives a \gls{cps} algorithm for solving the \gls{tsp}, fully exploiting the power of \gls{ps}' theoretical infinite resources, as well as the compactness of representation of \gls{cps}.  The use of \gls{cps}' generic maximally parallel multiset rewriting rules, and Prolog-like terms and unification, increases the expressive power of each rule, enabling a fixed-size \gls{ruleset} of five rules, applicable to digraphs of any size or complexity.   Further, the algorithm can solve any instance in \(n + 3\) steps, where \(n\) is the number of vertices in the digraph (thus the time complexity of the algorithm is \bigoh{n}).  This \lcnamecref{chap:tsp} primarily focuses on the \gls{tsp}, though begins with a solution to the less-complicated \gls{hpp} then expands that to the \gls{hcp}, and then expands upon that to solve the \gls{tsp}.  In the latter two cases, only relatively minor modifications to the rules are required at each step to take account of the stricter requirements of the problem.

The algorithms, and in particular the rules for them, are presented for the \gls{hpp} \& \gls{hcp} and \gls{tsp} cases respectively in \cref{sec:tsp:algohpp} and \cref{sec:tsp:algotsp}.  Worked examples for the \gls{tsp} are provided in \cref{sec:tsp:example}, applying the algorithm to a specific weighted graph and a modified digraph version of it.  \Cref{sec:tsp:variations} then considers some potential variations on the algorithm.  Finally, \cref{sec:tsp:simulation} briefly discusses simulations of the \gls{tsp} system written in SWI-Prolog, \fsharp{} and Erlang.