\section{Introduction}

% The Hamiltonian Path Problem (HPP) is a long-standing, well-known computationally hard (NP-hard) problem in Computer Science and related fields.  The problem consists of trying to determine whether for a given graph (digraph) there exists a traversal of the graph in which each node (vertex) is visited exactly once.  Depending on the particular problem at hand, the starting and/or ending node may or may not be arbitrarily selected.  Intrinsically linked, and arguably more useful, is \textit{describing} such a Hamiltonian path -- describing such a path proves the existence of it, and allows for its potential use in practical applications.  The Hamiltonian Cycle Problem (HCP) is a closely related variant, in which the Hamiltonian path must also be a cycle, i.e., the final node (vertex) in the path is the same as the starting one, such that every node (vertex) is visited exactly once after the start.

The \gls{hpp} is a long-standing, well-known computationally hard (NP-hard) problem in Computer Science and related fields.  The problem consists of trying to determine whether for a given graph (digraph) there exists a traversal of the graph in which each node (vertex) is visited exactly once.  Depending on the particular problem at hand, the starting and/or ending node may or may not be arbitrarily selected.  Intrinsically linked, and arguably more useful, is \textit{describing} such a Hamiltonian path -- describing such a path proves the existence of it, and allows for its potential use in practical applications.  The \gls{hcp} is a closely related variant, in which the Hamiltonian path must also be a cycle, i.e., the final node (vertex) in the path is the same as the starting one, such that every node (vertex) is visited exactly once after the start.

The \gls{hpp}/\gls{hcp} has been examined before through the lens of \gls{ps}, with different variants of \gls{ps} used such as \gls{tlps} \cite{Martin-Vide2003}, P~systems with active membranes \cite{Pan2006,Song2013}, Recogniser P~systems \cite{Chen2009}, Asynchronous P~systems \cite{Tagawa2012} and \gls{snps} \cite{Xue2013}.  Jim\'enez \textit{et al.} used the \gls{hpp} as an example computation when discussing complexity classes in \gls{ps} \cite{Jimenez2003}.  In fact, it was demonstrated relatively early in the history of \gls{ps} that some variants at least could be used to solve the \gls{hpp} in linear time \cite{Mutyam2001}.  This last approach, using \gls{ps} with membrane creation, is arguably the closest to our approach, which involves the instantiation of subcells (complex objects).

% The Travelling Salesman Problem (TSP) is an extension upon the \gls{hcp}, and is about finding the minimum cost Hamiltonian cycle in a \textit{weighted} graph.  It has been described as analogous to finding the shortest route for a travelling salesman to visit multiple cities in one trip (whence the name).  The problem is arguably the most useful of the three to solve in practice, and has been studied extensively, spawning many papers, dissertations and books on the topic (e.g. \cite{Smith2017,Ezugwu2017,Cook2012,Applegate2006} amongst many, many others).  A variety of sophisticated algorithms have been developed to solve the problem efficiently, in either the exact or approximate case.  This paper does not seek overturn this prior body of work.  Instead, it seeks to address the problem from a cP~systems perspective.  Note that we discuss here the \textit{optimisation} form of the \gls{tsp}, which is NP-Hard but not NP-Complete, and not the \textit{decision} form of the \gls{tsp}, which is NP-Complete.\footnote{See for example \url{https://www.ibm.com/developerworks/community/blogs/jfp/entry/no_the_tsp_isn_t_np_complete?lang=en} for an interesting but informal discussion of the difference.}  This demonstrates that cP~systems, and presumably other forms of P~systems too, are capable of solving in polynomial time problems for which there is no known traditional polynomial-time verification% -- a requirement for NP-Complete.

The \gls{tsp} is an extension upon the \gls{hcp}, and is about finding the minimum cost Hamiltonian cycle in a \textit{weighted} graph.  It has been described as analogous to finding the shortest route for a travelling salesman to visit multiple cities in one trip (whence the name).  The problem is arguably the most useful of the three to solve in practice, and has been studied extensively, spawning many papers, dissertations and books on the topic (e.g. \cite{Smith2017,Ezugwu2017,Cook2012,Applegate2006} amongst many, many others).  A variety of sophisticated algorithms have been developed to solve the problem efficiently, in either the exact or approximate case.  This paper does not seek overturn this prior body of work.  Instead, it seeks to address the problem from a cP~systems perspective.  Note that we discuss here the \textit{optimisation} form of the \gls{tsp}, which is NP-Hard but not NP-Complete, and not the \textit{decision} form of the \gls{tsp}, which is NP-Complete.\footnote{See for example \url{https://www.ibm.com/developerworks/community/blogs/jfp/entry/no_the_tsp_isn_t_np_complete?lang=en} for an interesting but informal discussion of the difference.}  This demonstrates that cP~systems, and presumably other forms of \gls{ps} too, are capable of solving in polynomial time problems for which there is no known traditional polynomial-time verification% -- a requirement for NP-Complete.

A small amount of work has been done on the \gls{tsp} from the perspective of membrane computing, beginning with the work of Nishida \cite{Nishida2006}, who used a combination of a membrane structure and pre-existing methods to search for an approximate solution in a space of solutions to the \gls{tsp} for a given digraph.  Others built on this approach by integrating techniques such as Genetic Algorithms \cite{Manalastas2013,He2014}, Ant Colony Optimisation \cite{Zhang2011} and Active Evolution \cite{Song2015}, along with more complex approaches for multiple salesman problems \cite{He2015}.  A paper by Chen \textit{et al.} \cite{Chen2011} was apparently also written on the topic, but no copy of that paper could be located.

Surprisingly however, given the multitude of solutions already demonstrated for the \gls{hcp}, all these \gls{tsp} papers have been written from the perspective of approximate solutions to the \gls{tsp}.  They typically take an approach of using membranes to divide up the search space of potential solutions, whilst applying other pre-existing techniques to the process.  These papers have used membranes to structure a search space, but in our view have not fully embraced the \gls{ps} model, e.g. none of them have specified typical \gls{ps} rewriting rules, instead applying other techniques within the subcells, and using \gls{ps} rules only to move potential solutions between cells.  More recently however, Guo and Dai presented a paper on solving the \gls{tsp} in the exact case using \gls{clps} \cite{Guo2017}, requiring roughly 50 rules.  By exploiting the well-known property of many \gls{ps} variants that time complexity can often be exchanged for space and/or processing complexity \cite{Paun1999,Paun2002a,Jimenez2003,Song2017}, the authors derived a \gls{ps} algorithm that can solve the \gls{tsp} in \(\mathcal{O}(n^2)\) time.

Inspired by \cite{Guo2017}, we derive a cP~systems algorithm for solving the \gls{tsp}, fully exploiting the power of \gls{ps}' theoretical infinite resources, as well as the compactness of representation of cP~systems.  Such systems have been described extensively in prior papers, in particular most recently in \cite{Nicolescu2018a}.  The use of cP~systems' generic maximally parallel multiset rewriting rules, and Prolog-like terms and unification, increases the expressive power of each rule, enabling us to specify here a fixed-size ruleset of five rules, applicable to digraphs of any size or complexity.   Further, our algorithm can solve any instance in \(n + 3\) steps, where \(n\) is the number of vertices in the digraph (thus the time complexity of our algorithm is \(\mathcal{O}(n)\)).  This paper mainly focuses on the \gls{tsp}, though we begin with a solution to the less-complicated \gls{hpp}, then expand that to the \gls{hcp}, and then expand upon that to solve the \gls{tsp}.  In the latter two cases, only relatively minor modifications to our rules are required at each step in order to take account of the stricter requirements of the problem.

For the sake of space, we hereafter assume that the reader is familiar with the basic concepts of \gls{ps} (see \cite{Paun2009} for a good, if slightly old, introduction to \gls{ps}), and the \gls{hcp} \& the \gls{tsp}.  In \autoref{sect:cpsystems} we present revised and improved material from previous papers that describes key aspects of cP~systems relevant to this paper (the reader is referred to \cite{Nicolescu2014a,RN-HW-ROMJIST14,Nicolescu2018a} also), before setting out a new cP~systems method for finding the minimum of a multiset in a single step, which requires two rules.  Our algorithms, and in particular the rules for them, are presented for the \gls{hpp} \& \gls{hcp} and \gls{tsp} cases respectively in \autoref{sect:algohpp} and \autoref{sect:algotsp}.  We provide worked examples for the \gls{tsp} in \autoref{sect:example}, applying our algorithm to a specific weighted graph and a modified digraph version of it.  We then consider some potential variations on the algorithm for differing results in \autoref{sect:variations}.  Finally, we briefly discuss simulations of the \gls{tsp} system written in SWI-Prolog, F\# and Erlang in \autoref{sect:simulation}.