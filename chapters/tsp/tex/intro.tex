\section{Background}

The \gls{hpp} is a long-standing, well-known computationally difficult (NP-hard) problem in Computer Science and related fields.  The problem consists of trying to determine whether for a given graph (digraph) there exists a traversal of the graph in which each node (vertex) is visited exactly once.  Depending on the particular problem at hand, the starting and/or ending node may or may not be arbitrarily selected.  Intrinsically linked, and arguably more useful, is \emph{describing} such a Hamiltonian path --- describing one proves the existence of it, and allows for its potential use in practical applications.  The \gls{hcp} is a closely related variant, in which the Hamiltonian path must also be a cycle, \ie{} the final node (vertex) in the path is the same as the starting one, such that every node (vertex) is visited exactly once after the start.

The \gls{hpp}/\gls{hcp} has been examined before through the lens of \gls{ps}, with different variants of \gls{ps} used such as \gls{tlps} \cite{Martin-Vide2003}, \gls{ps} with active membranes \cite{Pan2006,Song2013}, Recogniser \gls{ps} \cite{Chen2009}, Asynchronous \gls{ps} \cite{Tagawa2012} and \gls{snps} \cite{Xue2013}.  \citeauthor{Jimenez2003} used the \gls{hpp} as an example computation when discussing complexity classes in \gls{ps} \cite{Jimenez2003}.  In fact, it was demonstrated relatively early in the history of \gls{ps} that some variants at least could be used to solve the \gls{hpp} in linear time \cite{Mutyam2001}.  This last approach, using \gls{ps} with membrane creation, is arguably the closest to the approach used in this \namecref{chap:tsp}, which involves the repeated instantiation of subcells.

The \gls{tsp} is an extension upon the \gls{hcp}, and is about finding the minimum cost Hamiltonian cycle in a \emph{weighted} (di)graph.  It has been described as analogous to finding the shortest route for a travelling salesman to visit multiple cities in one trip (whence the name).  The problem is arguably the most useful of the three to solve in practice, and has been studied extensively, spawning many papers, dissertations and books on the topic (\eg{} \cite{Smith2017,Ezugwu2017,Cook2012,Applegate2006} among many, many others).  A variety of sophisticated algorithms have been developed to solve the problem efficiently, in either the exact or approximate case.  This \namecref{chap:tsp} does not seek to overturn this prior body of work.  Instead, it seeks to address the problem from a \gls{cps} perspective.  This \namecref{chap:tsp} discusses here the \emph{optimisation} form of the \gls{tsp}, which is NP-Hard but not NP-Complete, and not the \emph{decision} form of the \gls{tsp}, which is NP-Complete.\footnote{See for example \url{https://www.ibm.com/developerworks/community/blogs/jfp/entry/no_the_tsp_isn_t_np_complete?lang=en} for an interesting but informal discussion of the difference.}

A small amount of work has been done on the \gls{tsp} from the perspective of \gls{mc}, beginning with the work of \citeauthor{Nishida2006} \cite{Nishida2006}, who used a combination of a membrane structure and pre-existing methods to search for an approximate solution in a space of solutions to the \gls{tsp} for a given digraph.  Others built on this approach by integrating techniques such as Genetic Algorithms \cite{Manalastas2013,He2014}, Ant Colony Optimisation \cite{Zhang2011} and Active Evolution \cite{Song2015}, along with more complex approaches for multiple salesman problems \cite{He2015}.  A paper by \citeauthor{Chen2011} \cite{Chen2011} was apparently also written on the topic, but no copy could be located.

Surprisingly, however, given the multitude of solutions already demonstrated for the \gls{hcp}, all these \gls{tsp} papers have been written from the perspective of approximate solutions to the \gls{tsp}.  They typically take an approach of using membranes to divide up the search space of potential solutions, whilst applying other pre-existing techniques to the process.  These papers have used membranes to structure a search space, but arguably have not fully embraced the \gls{ps} model, \eg{} none of them have specified typical \gls{ps} rewriting rules, instead applying other techniques within the subcells, and using \gls{ps} rules only to move potential solutions between cells.  More recently, however, \citeauthor{Guo2017} presented a paper on solving the \gls{tsp} in the exact case using \gls{clps} \cite{Guo2017}, requiring roughly 50 rules.  By exploiting the property of many \gls{ps} variants that time complexity can often be exchanged for space and/or processing complexity \cite{Paun1999,Paun2002a,Jimenez2003,Song2017}, the authors derived a \gls{ps} algorithm that can solve the \gls{tsp} in \bigoh{n^2} time.

Inspired by \cite{Guo2017}, this \namecref{chap:tsp} derives a \gls{cps} algorithm for solving the \gls{tsp}, fully exploiting the power of \gls{ps}' theoretical infinite resources, as well as the compactness of representation of \gls{cps}.  The use of \gls{cps}' generic maximally parallel multiset rewriting rules, and Prolog-like terms and unification, increases the expressive power of each rule, enabling a fixed-size \gls{ruleset} of five rules, applicable to digraphs of any size or complexity.   Further, the algorithm can solve any instance in \(n + 3\) steps, where \(n\) is the number of vertices in the digraph (thus the time complexity of the algorithm is \bigoh{n}).  This \namecref{chap:tsp} primarily focuses on the \gls{tsp}, though begins with a solution to the less-complicated \gls{hpp} then expands that to the \gls{hcp}, and then expands upon that to solve the \gls{tsp}.  In the latter two cases, only relatively minor modifications to the rules are required at each step to take account of the stricter requirements of the problem.

The algorithms, and in particular the rules for them, are presented for the \gls{hpp} \& \gls{hcp} and \gls{tsp} cases respectively in \cref{sec:tsp:algohpp} and \cref{sec:tsp:algotsp}.  Worked examples for the \gls{tsp} are provided in \cref{sec:tsp:example}, applying the algorithm to a specific weighted graph and a modified digraph version of it.  \Cref{sec:tsp:variations} then considers some potential variations on the algorithm.  Finally, \cref{sec:tsp:simulation} briefly discusses simulations of the \gls{tsp} system written in SWI-Prolog, \fsharp{} and Erlang.