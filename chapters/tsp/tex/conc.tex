\section{\label{sec:tsp:conc}Conclusion \& Future Work}
This chapter defined a succinct \gls{cps} algorithm for solving the \gls{tsp} in \(\mathcal{O}(n)\) time, by using the capacity of \gls{cps} to create and manipulate complex subcells in only a few high-level steps.  This algorithm builds on a simpler version for finding Hamiltonian Paths and Cycles, requires only a fixed set of five rules, and takes \(n + 3\) steps to find a solution for any connected digraph of size \(n\), an improvement on the previous best known \gls{ps}-based solution to the \gls{tsp} (see \cref{tab:tsp:algocomp} for a comparison).

Simple examples were provided to demonstrate the operation of the algorithm.  The \gls{tsp} algorithm can operate, without modification to the ruleset, on any arbitrary weighted graph with a Hamiltonian cycle.   The algorithm requires only a specification of the graph encoded as subcells, and could be extended to detect the absence of a Hamiltonian cycle.

\begin{table}
\centering
\caption{Comparison of known exact \gls{ps} solutions to the \acrlong{tsp}}
\label{tab:tsp:algocomp}
\setlength{\tabcolsep}{5pt}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Algorithm}  & \multicolumn{1}{l}{\textbf{\begin{tabular}[c]{@{}c@{}}Num. of\\  rules\end{tabular}}} & \multicolumn{1}{l}{\textbf{\begin{tabular}[c]{@{}c@{}}Run time\\  order\end{tabular}}} \\ \midrule
Guo \& Dai \cite{Guo2017}          & $\sim$50                                   & \(\mathcal{O}(n^2)\)                                         \\
Cooper \& Nicolescu & 5                                          & \(\mathcal{O}(n)\)                                          \\ \bottomrule
\end{tabular}
\end{table}

% One-way multiset unification occurs frequently in \gls{cps}, with unification being used in every rule presented above.  An efficient algorithm to perform this task would be highly beneficial for creating useful simulations of systems (we are not aware of an efficient algorithm in the case of multisets).  For example, our simulations of the \gls{tsp} algorithm written in functional programming languages (see \cref{sec:tsp:simulation}) regularly simply iterate over all relevant objects in the system, even though frequently most will be of little use in a given function call, and so the simulations could benefit from improved unification in practice.

% We would like to further develop the capacity to simulate \gls{cps}, in particular developing more advanced techniques for translating \gls{cps} rules to efficient parallel code.  Work down this avenue has not begun as yet, however.