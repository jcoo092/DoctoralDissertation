\section{Introduction}

Many Computer Vision and Image Processing operations have some potential for parallelism.  Indeed, a number of them can be regarded as `embarrassingly parallel', that is to say that the process involves a considerable number of sub-process steps that do not depend on each other, and so those steps may be performed concurrently without complication.  Some of those algorithms either are explicitly characterised in terms of message passing, such as \gls{sm} with \gls{bp} \cite{Liang2011} or \gls{sgm} \cite{Drory2014}, or could be viewed as such, \eg{} \glspl{mwt} applied to images.

Median filtering \cite[Chap. 3.4.1]{Gimelfarb2018}, \cite{Fisher2016} is an operation in image processing used to remove random `salt \& pepper' noise from images.  Such noise is characterised by pixel colouration values at the extreme high and low ends of the range of possible values.  At its simplest, median filtering recovers an approximation of the non-noisy image by taking the median of all pixel values in a window around each pixel and creating a new image using said median values for the pixels.

This \namecref{chap:median} seeks firstly to model median filtering using \gls{cps}, as another test of the power and versatility of \gls{cps}, and secondly to explore whether using \gls{cml} -- as a method of structuring computations around message passing -- could be beneficial when applied to a \gls{mwt}, using the \gls{medianfilter} as its particular example.  The focus is on examining the potential benefit of using a different principle to structure the processing, as much as it is on the achieved results.  It is hypothesised that the same results in terms of processing the image can be achieved, but at slightly slower rates of processing due to overheads from the message passing which, strictly speaking, are unnecessary in the case of a \gls{mwt}.