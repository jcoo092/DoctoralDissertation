\section{Formal Models of Concurrent Computation}
Perhaps the earliest (or at least, the earliest that is still widely known) formalised model of concurrent computation is the Petri Net \cite{Dennis2011}, first conceived of by Carl Petri, initially for the purpose of describing chemical processes \cite{Petri2008}.

\begin{anfxerror}{Why not Petri Nets?}
Why are Petri Nets not more popular?  Why do we choose \gls{csp} or \glspl{actor} or \gls{ps} over them?
\end{anfxerror}

\cite{Varela2013}

This work 

\subsection{\glsentrylong{csp} \& Pi~Calculus}
\gls{csp} is a `process algebra' and abstract model of concurrent computation put forward by Hoare \cite{Hoare1985,Roscoe2011}.  A typical sequential computation is represented by a `process'.  Processes' ``behaviour is described in terms of the occurrence and availability of abstract entities called \textit{events}'' \cite[p.~478]{Roscoe2011}.  Should more than one event be available simultaneously for a given process, then one will be chosen non-deterministically.  This choice is internal to the process, and not influenced by or visible to any other process.  %E.g. for a situation where there is one possible event \(a\) at a given point in time, the process \(P\) will choose that event and then proceed according to the result, written as: \[ a \rightarrow P(a) \]

Concurrency is introduced by the existence of multiple processes.  In general, the processes evolve independently, responding to events as they come.  Should a particular event appear in the alphabet of multiple processes, however, then all processes \emph{must} choose to participate in that event at the same time.  Should all processes involved make such a choice, they engage in a synchronous multi-way atomic synchronisation (hence `communicating').  \gls{csp} has provided significant inspiration for concurrency design in a number of programming languages, notably including Ada \cite{Defense1983,Taft2013}, Occam \cite{Elizabeth1987}, Google's Go \cite{Meyerson2014} (not to be confused with the earlier language Go! \cite{Clark2004}, which itself was explicitly designed for concurrency) and \gls{cml} \cite{Reppy2011}. 

Milner appreciated \gls{csp}, which advanced concurrency models by explicitly incorporating \emph{synchronised} interaction, something Milner's earlier Calculus for Communicating Systems \cite{Milner1980} had lacked  \cite{Milner1993}.  Milner still regarded \gls{csp} as incomplete, however, in that it had no support for the concept of `mobility' -- i.e. the ability of the system to reconfigure itself during operation.  Pi Calculus was created as an attempt to build upon those earlier systems but present a complete calculus of concurrent computation in much the same way that Lambda Calculus \cite{Barendregt1984} is a complete calculus for sequential computation.\footnote{Milner also pointed out that sequential computation is, in fact, a special case of concurrent computation.}

\subsection{\label{subsec:actors}\texorpdfstring{\Glspl{actor}}{Actors}}
The \gls{actor} \cite{Agha1986} model was introduced by Hewitt \cite{Hewitt1973}.  Much like \gls{csp} \& its cousins, the \gls{actor} model is based around the concept of separated, sequential but communicating processes which exchange messages.  Again, the processes make decisions and proceed based on their communications.  A key difference, however, is that in the \gls{actor} model the message exchanges are \emph{a}synchronous.  Each \gls{actor} has its own `mailbox', and may send messages to other \glspl{actor} so long as it knows their name (which is equivalent for this purpose to a concept of an address for the \gls{actor}), \emph{but does not wait at all for a response before proceeding}.

The \gls{actor} model is a popular one for concurrent programming, possibly owing to its intuitive concept.  The fact that communication is asynchronous makes \glspl{actor} much more suitable for modelling distributed systems without shared memory than \gls{csp} or similar -- \glspl{actor} can send messages and proceed without (necessarily) needing to wait for a response, instead continuing to process based on the messages they themselves have received.  By contrast, a system with synchronous communication would have prohibitive time costs, given the relative slow speed of typical links between distributed computers as compared to their capacity for local processing.  Many \gls{actor} systems have been implemented for different programming languages (e.g. \cite{Varela2001,Srinivasan2008,Charousset2016,Bernstein2016} \fxnote[inline,nomargin]{[need more refs?]}), and in fact it is a core component, and perhaps largely responsible for the success, of Erlang/OTP \cite{Armstrong2010,Armstrong2013,Vinoski2012}.  A relatively new language, Pony \cite{Clebsch2015,Clebsch2017}, takes this even further.
\begin{anfxnote}{Positive example for actors?}
In Concurrency in .NET, Terrell described using an actor to control access to a shared resource and stated that it was an extremely effective solution.
\end{anfxnote}

\Glspl{actor}, when used for non-trivial real-world software, have been criticised at times \cite{Welsh2013,Stucchio2013}.  While some of the criticisms described are implementation-specific (relating to Akka, a Scala \gls{actor} library), a common thread is that \glspl{actor} do not compose well.  This has the negative consequence that it is difficult to combine an \gls{actor} with anything else to create a new abstraction, and can require extensive modifications in source code to make relatively simple changes.

\subsection{Join Calculus}

\begin{anfxwarning}{Join Calc refs}
Chemical abstract machine, joinads, Scala communicating objects (IIRC, that was join calculus based), reagents
\end{anfxwarning}

\subsection{Others}
Mobility calculus.  Others?

% \subsection{Criticisms}

% Gorlatch \cite{Gorlatch2004} argued against basic message passing, decrying it as an unnecessary and unhelpful complication and favouring \fxerror*{What does `collective operations' mean?}{`collective' operations} instead.  This criticism focused upon \gls{mpi} as it was at the time, however, and made no reference to either Actors or \gls{csp}. \fxerror{Does subsection this truly belong here?}
