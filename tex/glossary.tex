% \makeglossaries

% Acronyms (sorted in alphabetical order by their label, rather than their full definition)

%% A-M
\newacronym{bp}{BP}{belief~propagation}
\newacronym{cham}{CHAM}{chemical abstract machine}
\newacronym{cp}{CP}{concurrent~propagation}
\newacronym{csp}{CSP}{communicating sequential processes}
\newacronym{dpsm}{DPSM}{dynamic~programming \gls{sm}}
\newacronym{dsp}{DSP}{digital signal processor}
\newacronym{enps}{ENPS}{enzymatic numerical P~systems}
\newacronym{fifo}{FIFO}{first-in-first-out}
\newacronym{fpga}{FPGA}{field-programmable gate array}
\newacronym{fps}{FPS}{frames per second}
\newacronym{gpu}{GPU}{graphics processing unit}
\newacronym{gpgpu}{GPGPU}{general-purpose \glsxtrshort{gpu}}
\newacronym{lbp}{LBP}{loopy \gls{bp}}
\newacronym{mpbsm}{MPBSM}{message passing-based \gls{sm}}
\newacronym{mrf}{MRF}{Markov random field}
\newacronym{mwt}{MWT}{moving window transform}

%% N-Z
\newacronym{ndcsm}{NDCSM}{noise-driven concurrent \gls{sm}}
\newacronym{nm}{NM}{neighbourhood messaging}
\newacronym{nmp}{NMP}{neighbourhood message passing}
\newacronym{oq}{OQ}{oracle query}
\newacronym{pe}{proxel}{processing element}
\newacronym{pram}{PRAM}{parallel random access machine}
\newacronym{sad}{SAD}{sum of absolute differences}
\newacronym{skps}{SKPS}{simple kernel P~systems}
\newacronym{ssd}{SSD}{sum of squared differences}

% Combo glossary & acronyms

% A-M
\newdefacr{cml}{CML}{Concurrent~ML}{Concurrent~ML}{A programming style introduced by John Reppy as an extension of the pre-existing programming language Standard~ML.  Conceptually, Concurrent~ML has a lot in common with \glsxtrlong{csp} \cite{Hoare1985}.  Both involve every logical process mostly advancing on its own, but sometimes synchronising with others over channels (see also \vref{fig:back:cml_exchange}).  Concurrent~ML is described in detail in \cite{Reppy2007}.}
\newdefacr{gcp}{GCP}{graph colouring problem}{Graph Colouring Problem}{The problem of finding a way to colour the nodes in a graph, such that no adjacent nodes share a colour.  This problem is typically further constrained to using a maximum number of colours for the entire graph, or finding the minimum number of colours required to perform the colouring.}
\newdefacr{hcp}{HCP}{Hamiltonian cycle problem}{Hamiltonian Cycle Problem}{Closely related to the \glsdesc{hpp}.  In this problem, the Hamiltonian Path must also be a cycle, \ie{} it ends back at the origin node.}
\newdefacr{hpp}{HPP}{Hamiltonian path problem}{Hamiltonian Path Problem}{The problem of determining whether, for a given graph, there exists a traversal of the graph in which each node is visited exactly once.}
\newdefacr{lhs}{LHS}{left-hand side}{Left-hand Side}{A part of the definition of a \gls{cps} rule.  It is the list of terms which \emph{must} be present and as-yet unused in a rule at the current step, in order for the current rule to be applicable.  All terms appearing here are deleted from the containing cell at the end of the step.}

% N - Z
\newdefacr{rhs}{RHS}{right-hand side}{Right-hand Side}{A part of the definition of a \gls{cps} rule.  It is the list of terms which are created by the rule's application, and appear in the relevant cell at the end of the step.}
%
%
\newdefacr{tsp}{TSP}{travelling salesman problem}{Travelling Salesman Problem}{An extension of the \glsdesc{hcp}.  Here, the edges between nodes have weights, and the goal of the problem is to find a minimum weight Hamiltonian cycle on the graph.}

%% A-M
\newglossaryentry{actor}{text={actor},name={Actor},description={A model of message-passing-based concurrent programming originally developed  chiefly by Carl Hewitt, and further developed for practical programming by Gul Agha and collaborators.  Its defining characteristics are that it uses asynchronous messaging, whereby the sender and receiver do not need to coordinate or synchronise at all; and that instead of using channels or similar as a go-between, Actors send messages directly to each other, which necessitates ``knowing'' (\ie{} holding a reference to) the intended recipient.  Notable examples of implementations of Actors are found in the programming languages Erlang and Pony, and the Scala library Akka.}}
%
\newglossaryentry{clps}{text={cell-like P~systems},name={Cell-like P~Systems},plural={cell-like P~system},description={The original \gls{ps} variant first proposed by Gheorghe PÄƒun, based on the operation of chemicals inside biological cells.  The main characteristic of cell-like P~systems is that the chemicals are represented by an unlimited variety of atomic objects, and are contained within one or more membranes.  Every cell-like P~system has an outermost membrane, the \emph{skin membrane} which separates the cell from the \emph{environment}, and may have more membranes inside itself.  These latter membranes are nested in such a fashion that they resemble a graphical tree.  Each \gls{compartment} delimited by a membrane has a separate \gls{ruleset}, though the \glspl{ruleset} are not necessarily unique.  Rules may create and remove chemicals based on the presence (or absence) of other chemicals inside a membrane, and also send chemicals to an inner \emph{child} membrane, or to an outer \emph{parent} membrane.  Perhaps due to it being the original variant (and thus pre-dating the term ``cell-like P systems''), some forms of P~systems which could be regarded as cell-like are not necessarily labelled as such, \eg{} P~systems with active membranes.}}
%
% \newglossaryentry{compartment}{text={compartment},name={Compartment},description={A generic umbrella term for the processing units, which also act as the containers of the system's objects, of a given \gls{ps} type.  For example, these are: the membranes of \gls{clps}; the cells of \gls{tlps}; the neurons of \gls{snps}; and the \glspl{tlc} of \gls{cps} --- though in the case of \gls{cps} the data-only complex objects are sometimes also described as sub-compartments or micro-compartments, because they still contain objects.}}
\newglossaryentry{compartment}{text={compartment},name={Compartment},description={A generic umbrella term for the combined processing units and object containers of a given \gls{ps} type.  For example, these are: the membranes of \gls{clps}; the cells of \gls{tlps}; the neurons of \gls{snps}; and the \glspl{tlc} of \gls{cps} --- though in the case of \gls{cps} the data-only complex objects are sometimes also described as sub-compartments or micro-compartments, because they still contain objects.}}
%
\newglossaryentry{cps}{text={cP~systems},name={cP~Systems},description={A variant of \gls{ps} created by Radu Nicolescu and developed further by Nicolescu and collaborators.  The main point of difference between cP~systems and other variants is that, in general, cP~systems is `higher-level'.  That is, instead of specifying (semi-)uniform families of rules customised to each specific problem of a given type, cP~systems \glspl{ruleset} typically cover all possible problem specifications without customisation ahead-of-time through the use of variables.  The cP~systems `runtime' performs unification over the variables.  Furthermore, only the \glspl{tlc} have associated rules, and all other terms contained within are merely inert objects.  See also \cref{chap:cpsystems}.},plural={cP~system}}
%
\newglossaryentry{disparity}{text={disparity},name={Disparity},description={The shift, measured as a number of pixels, of a point in one stereo image to its location in the other image.  When combined with information about the cameras used to capture the images which is derived from calibration, the measured disparity is used to estimate the distance from the cameras to the point in the scene.  Disparity is often also referred to as `parallax'.}}
%
\newglossaryentry{disparitymap}{text={disparity map},name={Disparity Map},description={An output array/image (often just using a single channel of 8- or 16-bit integers) which encodes the final estimated disparities for every pixel in the input images.  The range of values in a disparity map itself is restricted to range of possible disparities used in the \gls{sm} algorithm.  It is common, however, to adjust the disparity map in some fashion to make differences in disparity estimates more visible through techniques such as histogram equalisation.  Most published figures of disparity maps will have had such an adjustment applied to make them more useful.  Disparity maps are sometimes also referred to as `digital parallax maps.'}}
%
\newglossaryentry{fne}{description={The `standard' neighbourhood arrangement in situations such as \glsxtrlong{lbp}.  When used in reference to a grid, it typically means the other locations in the grid immediately to the left, right, above and below.},text={four-neighbourhood},name={Four-neighbourhood}}
%
\newglossaryentry{functor}{description={In the context of \gls{cps}, a functor is the label applied to the delimiters of a complex term.  \Eg{} for \(\cpfunc{a}{\cpfunc{b}{c}}\) both \(a\) and \(b\) are functors, because they are the outer label for their respective inner terms.  ``Functor'' is also sometimes used as a shorthand to refer to the complex term as a whole.  Strictly speaking, this is incorrect but convenient nevertheless, as writing \enquote{the complex term denoted by the functor \(a\)} is usually overly verbose.},text={functor},name={Functor}}
%
\newglossaryentry{gs}{description={In the context of \glsxtrlong{nmp}, this refers to an approach to messaging whereby the entire lattice waits until every \glsxtrshort{pe} in the lattice has finished its messaging for a given generation before proceeding to the next generation.},text={globally-synchronous},name={Globally-synchronous}}
%
\newglossaryentry{inhibitor}{name={Inhibitor},text={inhibitor},description={In \gls{cps}, an inhibitor on a rule denotes an object which \emph{must not} be present in the relevant \gls{tlc} for the rule to be applicable.}}
%
\newglossaryentry{ls}{description={In the context of \glsxtrlong{nmp}, this refers to an approach to messaging whereby every \glsxtrshort{pe} in the lattice waits until it has received \emph{all} messages pertaining to one generation before accepting any messages pertaining to a subsequent generation.},text={locally-synchronous},name={Locally-synchronous}}
%
\newglossaryentry{mc}{text={membrane computing},name={Membrane Computing},description={A computational model inspired by the functioning of biological systems, specifically the interactions of chemicals inside the membranes of a biological cell.  The terms Membrane Computing and P systems are normally used interchangeably.}}
%
\newglossaryentry{mecosim}{name={MeCoSim},description={Software used to simulate arbitrary P~systems, from a multitude of variants.  MeCoSim was created and is maintained by researchers from Universidad de Sevilla (University of Seville) in Spain (see further \cite{MeCoSim}).  Generally, rules for a given system are specified with a \gls{plingua} file.  These rules can then be run on a specific set of starting objects, with MeCoSim reporting the outcome from executing the rules at the end of each step.}}
%
\newglossaryentry{medianfilter}{text={median filter},name={Median Filter},description={An image processing technique often used to remove `salt \& pepper' noise from images.  Every pixel's value is updated to the median value of it and its neighbours, in a given neighbourhood.  It is an embarassingly-parallel problem in that each pixel in the image can compute its median without relying on other pixels' results, so long as it can observe their current value.  The necessity for performing selection of the median across the neighbourhood, however, means that it is non-trivial to implement a fast median filter.  It does not easily reduce to basic arithmetic operations only.}}
%
\newglossaryentry{ms}{text={micro-surgery},name={Micro-surgery},description={An alternative operation that can be performed on \gls{cps}' compound terms.  Instead of each rule application seizing control of the entire term, it merely takes hold of a subset of the term's contents.  A major benefit of this is to enable in a single step arithmetic on numeric multisets that would instead require multiple iterations to complete.},plural={micro-surgeries}}

%% N-Z
\newglossaryentry{promoter}{name={Promoter},text={promoter},description={In \gls{cps}, a promoter on a rule denotes an object which \emph{must} be present in the relevant \gls{tlc} for the rule to be applicable, but which is \emph{not} consumed or deleted by the rule.}}
%
\newglossaryentry{ps}{name={P~Systems},see={mc},text={P~systems},description={An alternative name for \gls{mc}.},plural={P~system},}
%
\newglossaryentry{plingua}{name={P-Lingua}, description={A plain-text markup language used to represent \gls{ps} specifications in computer files, readable by both humans and computers.}}
%
\newglossaryentry{ruleset}{text={ruleset},name={Ruleset},description={The rules associated with a particular \gls{compartment} in a given \gls{ps} variant.}}
\newglossaryentry{sm}{text={stereo~matching},name={Stereo~Matching},description={A family of methods to match points from different images of the same scene to estimate the distance from the capturing cameras to objects in the scene.}}
\newglossaryentry{snps}{text={spiking neural P~systems},name={Spiking Neural P~Systems},description={Spiking neural P~systems is one of the three main \gls{ps} variants in common use today, and was introduced most recently.  Whereas \gls{clps} is based on intra-cellular chemical interactions, and \gls{tlps} on inter-cellular interactions, spiking neural P~systems is explicitly based on the idea of neurons in the brain interacting via synapses.  In principle, the communication-based nature of spiking neural P~systems makes it closer to \gls{tlps} than \gls{clps}, but unlike those two it uses only a single object in its alphabet, the spike.  This difference can make solutions to some problems more complex, but has the advantage that it makes it (comparatively) easy to implement those solutions with linear algebra operations.}}
\newglossaryentry{tlc}{text={top-level cell},name={Top-level Cell},description={The outermost membranes/\glspl{compartment} and processing units of \gls{cps}, loosely equivalent to the skin membrane of \gls{clps}.  These are the only objects in the system which have rules and are `active'.  Generally, all other objects present in a system except channels are found inside a top-level cell.}}
\newglossaryentry{tlps}{text={tissue-like P~systems},name={Tissue-like P~Systems},description={Tissue-like P~systems is one of the oldest \gls{ps} variants, especially of those still in common use, and is based on the transmission of chemicals between cells via channels in biological tissue (rather than movement of chemicals through membranes within a cell like \gls{clps}).  A notable aspect of tissue-like P~systems is that they often include no ability for the cells to process their own contents.  Instead, all computation arises as a consequence of the communication.},plural={tissue-like P~system}}